// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `SecureDistributedChat.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <cstddef>
#include <SecureDistributedChat.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

static const ::std::string __sdc__SessionI__logout_name = "logout";

static const ::std::string __sdc__SessionI__retrieveUser_name = "retrieveUser";

static const ::std::string __sdc__SessionI__initChat_name = "initChat";

static const ::std::string __sdc__SessionI__leaveChat_name = "leaveChat";

static const ::std::string __sdc__SessionI__invite_name = "invite";

static const ::std::string __sdc__SessionI__sendMessage_name = "sendMessage";

static const ::std::string __sdc__SessionI__deleteUser_name = "deleteUser";

static const ::std::string __sdc__SessionI__saveLog_name = "saveLog";

static const ::std::string __sdc__SessionI__retrieveLoglist_name = "retrieveLoglist";

static const ::std::string __sdc__SessionI__retrieveLog_name = "retrieveLog";

static const ::std::string __sdc__SessionI__saveContactList_name = "saveContactList";

static const ::std::string __sdc__SessionI__retrieveContactList_name = "retrieveContactList";

static const ::std::string __sdc__AuthenticationI__registerUser_name = "registerUser";

static const ::std::string __sdc__AuthenticationI__login_name = "login";

static const ::std::string __sdc__AuthenticationI__echo_name = "echo";

static const ::std::string __sdc__ChatClientCallbackI__initChat_name = "initChat";

static const ::std::string __sdc__ChatClientCallbackI__addChatParticipant_name = "addChatParticipant";

static const ::std::string __sdc__ChatClientCallbackI__removeChatParticipant_name = "removeChatParticipant";

static const ::std::string __sdc__ChatClientCallbackI__appendMessageToChat_name = "appendMessageToChat";

static const ::std::string __sdc__ChatClientCallbackI__echo_name = "echo";

static const ::std::string __sdc__InterServerI__retrieveUser_name = "retrieveUser";

static const ::std::string __sdc__InterServerI__invite_name = "invite";

static const ::std::string __sdc__InterServerI__sendMessage_name = "sendMessage";

static const ::std::string __sdc__InterServerI__leaveChat_name = "leaveChat";

static const ::std::string __sdc__InterServerI__clientInitChat_name = "clientInitChat";

static const ::std::string __sdc__InterServerI__clientAddChatParticipant_name = "clientAddChatParticipant";

static const ::std::string __sdc__InterServerI__clientRemoveChatParticipant_name = "clientRemoveChatParticipant";

static const ::std::string __sdc__InterServerI__clientAppendMessageToChat_name = "clientAppendMessageToChat";

::Ice::Object* IceInternal::upCast(::sdc::SessionI* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::sdc::SessionI* p) { return p; }

::Ice::Object* IceInternal::upCast(::sdc::AuthenticationI* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::sdc::AuthenticationI* p) { return p; }

::Ice::Object* IceInternal::upCast(::sdc::ChatClientCallbackI* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::sdc::ChatClientCallbackI* p) { return p; }

::Ice::Object* IceInternal::upCast(::sdc::InterServerI* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::sdc::InterServerI* p) { return p; }

void
sdc::__read(::IceInternal::BasicStream* __is, ::sdc::SessionIPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::sdc::SessionI;
        v->__copyFrom(proxy);
    }
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ice_writeSessionIPrx(const ::Ice::OutputStreamPtr& __outS, const ::sdc::SessionIPrx& v)
{
    __outS->write(v);
}

void
sdc::ice_readSessionIPrx(const ::Ice::InputStreamPtr& __inS, ::sdc::SessionIPrx& v)
{
    __inS->read(v);
}

void
sdc::ice_writeSessionI(const ::Ice::OutputStreamPtr& __outS, const ::sdc::SessionIPtr& v)
{
    __outS->writeObject(v);
}

void
sdc::ice_readSessionI(const ::Ice::InputStreamPtr& __inS, ::sdc::SessionIPtr& __v)
{
    __inS->read(__v);
}
#endif

void
sdc::__read(::IceInternal::BasicStream* __is, ::sdc::AuthenticationIPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::sdc::AuthenticationI;
        v->__copyFrom(proxy);
    }
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ice_writeAuthenticationIPrx(const ::Ice::OutputStreamPtr& __outS, const ::sdc::AuthenticationIPrx& v)
{
    __outS->write(v);
}

void
sdc::ice_readAuthenticationIPrx(const ::Ice::InputStreamPtr& __inS, ::sdc::AuthenticationIPrx& v)
{
    __inS->read(v);
}

void
sdc::ice_writeAuthenticationI(const ::Ice::OutputStreamPtr& __outS, const ::sdc::AuthenticationIPtr& v)
{
    __outS->writeObject(v);
}

void
sdc::ice_readAuthenticationI(const ::Ice::InputStreamPtr& __inS, ::sdc::AuthenticationIPtr& __v)
{
    __inS->read(__v);
}
#endif

void
sdc::__read(::IceInternal::BasicStream* __is, ::sdc::ChatClientCallbackIPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::sdc::ChatClientCallbackI;
        v->__copyFrom(proxy);
    }
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ice_writeChatClientCallbackIPrx(const ::Ice::OutputStreamPtr& __outS, const ::sdc::ChatClientCallbackIPrx& v)
{
    __outS->write(v);
}

void
sdc::ice_readChatClientCallbackIPrx(const ::Ice::InputStreamPtr& __inS, ::sdc::ChatClientCallbackIPrx& v)
{
    __inS->read(v);
}

void
sdc::ice_writeChatClientCallbackI(const ::Ice::OutputStreamPtr& __outS, const ::sdc::ChatClientCallbackIPtr& v)
{
    __outS->writeObject(v);
}

void
sdc::ice_readChatClientCallbackI(const ::Ice::InputStreamPtr& __inS, ::sdc::ChatClientCallbackIPtr& __v)
{
    __inS->read(__v);
}
#endif

void
sdc::__read(::IceInternal::BasicStream* __is, ::sdc::InterServerIPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::sdc::InterServerI;
        v->__copyFrom(proxy);
    }
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ice_writeInterServerIPrx(const ::Ice::OutputStreamPtr& __outS, const ::sdc::InterServerIPrx& v)
{
    __outS->write(v);
}

void
sdc::ice_readInterServerIPrx(const ::Ice::InputStreamPtr& __inS, ::sdc::InterServerIPrx& v)
{
    __inS->read(v);
}

void
sdc::ice_writeInterServerI(const ::Ice::OutputStreamPtr& __outS, const ::sdc::InterServerIPtr& v)
{
    __outS->writeObject(v);
}

void
sdc::ice_readInterServerI(const ::Ice::InputStreamPtr& __inS, ::sdc::InterServerIPtr& __v)
{
    __inS->read(__v);
}
#endif

sdc::SDCException::SDCException(const ::std::string& __ice_what) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException(),
#else
    ::Ice::UserException(),
#endif
    what(__ice_what)
{
}

sdc::SDCException::~SDCException() throw()
{
}

static const char* __sdc__SDCException_name = "sdc::SDCException";

::std::string
sdc::SDCException::ice_name() const
{
    return __sdc__SDCException_name;
}

::Ice::Exception*
sdc::SDCException::ice_clone() const
{
    return new SDCException(*this);
}

void
sdc::SDCException::ice_throw() const
{
    throw *this;
}

void
sdc::SDCException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::sdc::SDCException"), false);
    __os->startWriteSlice();
    __os->write(what);
    __os->endWriteSlice();
}

void
sdc::SDCException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->read(what);
    __is->endReadSlice();
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::SDCException::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(::std::string("::sdc::SDCException"));
    __outS->startSlice();
    __outS->write(what);
    __outS->endSlice();
}

void
sdc::SDCException::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        std::string s;
        __inS->read(s);
    }
    __inS->startSlice();
    __inS->read(what);
    __inS->endSlice();
}
#endif

struct __F__sdc__SDCException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::sdc::SDCException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__sdc__SDCException__Ptr = new __F__sdc__SDCException;

const ::IceInternal::UserExceptionFactoryPtr&
sdc::SDCException::ice_factory()
{
    return __F__sdc__SDCException__Ptr;
}

class __F__sdc__SDCException__Init
{
public:

    __F__sdc__SDCException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::sdc::SDCException", ::sdc::SDCException::ice_factory());
    }

    ~__F__sdc__SDCException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::sdc::SDCException");
    }
};

static __F__sdc__SDCException__Init __F__sdc__SDCException__i;

#ifdef __APPLE__
extern "C" { void __F__sdc__SDCException__initializer() {} }
#endif

sdc::AuthenticationException::AuthenticationException(const ::std::string& __ice_what) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException(__ice_what)
#else
    ::sdc::SDCException(__ice_what)
#endif
{
}

sdc::AuthenticationException::~AuthenticationException() throw()
{
}

static const char* __sdc__AuthenticationException_name = "sdc::AuthenticationException";

::std::string
sdc::AuthenticationException::ice_name() const
{
    return __sdc__AuthenticationException_name;
}

::Ice::Exception*
sdc::AuthenticationException::ice_clone() const
{
    return new AuthenticationException(*this);
}

void
sdc::AuthenticationException::ice_throw() const
{
    throw *this;
}

void
sdc::AuthenticationException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::sdc::AuthenticationException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__write(__os);
#else
    ::sdc::SDCException::__write(__os);
#endif
}

void
sdc::AuthenticationException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__read(__is, true);
#else
    ::sdc::SDCException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::AuthenticationException::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(::std::string("::sdc::AuthenticationException"));
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__write(__outS);
#else
    ::sdc::SDCException::__write(__outS);
#endif
}

void
sdc::AuthenticationException::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        std::string s;
        __inS->read(s);
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__read(__inS, true);
#else
    ::sdc::SDCException::__read(__inS, true);
#endif
}
#endif

struct __F__sdc__AuthenticationException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::sdc::AuthenticationException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__sdc__AuthenticationException__Ptr = new __F__sdc__AuthenticationException;

const ::IceInternal::UserExceptionFactoryPtr&
sdc::AuthenticationException::ice_factory()
{
    return __F__sdc__AuthenticationException__Ptr;
}

class __F__sdc__AuthenticationException__Init
{
public:

    __F__sdc__AuthenticationException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::sdc::AuthenticationException", ::sdc::AuthenticationException::ice_factory());
    }

    ~__F__sdc__AuthenticationException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::sdc::AuthenticationException");
    }
};

static __F__sdc__AuthenticationException__Init __F__sdc__AuthenticationException__i;

#ifdef __APPLE__
extern "C" { void __F__sdc__AuthenticationException__initializer() {} }
#endif

sdc::SessionException::SessionException(const ::std::string& __ice_what) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException(__ice_what)
#else
    ::sdc::SDCException(__ice_what)
#endif
{
}

sdc::SessionException::~SessionException() throw()
{
}

static const char* __sdc__SessionException_name = "sdc::SessionException";

::std::string
sdc::SessionException::ice_name() const
{
    return __sdc__SessionException_name;
}

::Ice::Exception*
sdc::SessionException::ice_clone() const
{
    return new SessionException(*this);
}

void
sdc::SessionException::ice_throw() const
{
    throw *this;
}

void
sdc::SessionException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::sdc::SessionException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__write(__os);
#else
    ::sdc::SDCException::__write(__os);
#endif
}

void
sdc::SessionException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__read(__is, true);
#else
    ::sdc::SDCException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::SessionException::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(::std::string("::sdc::SessionException"));
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__write(__outS);
#else
    ::sdc::SDCException::__write(__outS);
#endif
}

void
sdc::SessionException::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        std::string s;
        __inS->read(s);
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__read(__inS, true);
#else
    ::sdc::SDCException::__read(__inS, true);
#endif
}
#endif

struct __F__sdc__SessionException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::sdc::SessionException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__sdc__SessionException__Ptr = new __F__sdc__SessionException;

const ::IceInternal::UserExceptionFactoryPtr&
sdc::SessionException::ice_factory()
{
    return __F__sdc__SessionException__Ptr;
}

class __F__sdc__SessionException__Init
{
public:

    __F__sdc__SessionException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::sdc::SessionException", ::sdc::SessionException::ice_factory());
    }

    ~__F__sdc__SessionException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::sdc::SessionException");
    }
};

static __F__sdc__SessionException__Init __F__sdc__SessionException__i;

#ifdef __APPLE__
extern "C" { void __F__sdc__SessionException__initializer() {} }
#endif

sdc::UserHandlingException::UserHandlingException(const ::std::string& __ice_what) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException(__ice_what)
#else
    ::sdc::SessionException(__ice_what)
#endif
{
}

sdc::UserHandlingException::~UserHandlingException() throw()
{
}

static const char* __sdc__UserHandlingException_name = "sdc::UserHandlingException";

::std::string
sdc::UserHandlingException::ice_name() const
{
    return __sdc__UserHandlingException_name;
}

::Ice::Exception*
sdc::UserHandlingException::ice_clone() const
{
    return new UserHandlingException(*this);
}

void
sdc::UserHandlingException::ice_throw() const
{
    throw *this;
}

void
sdc::UserHandlingException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::sdc::UserHandlingException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__write(__os);
#else
    ::sdc::SessionException::__write(__os);
#endif
}

void
sdc::UserHandlingException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__read(__is, true);
#else
    ::sdc::SessionException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::UserHandlingException::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(::std::string("::sdc::UserHandlingException"));
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__write(__outS);
#else
    ::sdc::SessionException::__write(__outS);
#endif
}

void
sdc::UserHandlingException::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        std::string s;
        __inS->read(s);
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__read(__inS, true);
#else
    ::sdc::SessionException::__read(__inS, true);
#endif
}
#endif

struct __F__sdc__UserHandlingException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::sdc::UserHandlingException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__sdc__UserHandlingException__Ptr = new __F__sdc__UserHandlingException;

const ::IceInternal::UserExceptionFactoryPtr&
sdc::UserHandlingException::ice_factory()
{
    return __F__sdc__UserHandlingException__Ptr;
}

class __F__sdc__UserHandlingException__Init
{
public:

    __F__sdc__UserHandlingException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::sdc::UserHandlingException", ::sdc::UserHandlingException::ice_factory());
    }

    ~__F__sdc__UserHandlingException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::sdc::UserHandlingException");
    }
};

static __F__sdc__UserHandlingException__Init __F__sdc__UserHandlingException__i;

#ifdef __APPLE__
extern "C" { void __F__sdc__UserHandlingException__initializer() {} }
#endif

sdc::MessageException::MessageException(const ::std::string& __ice_what) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException(__ice_what)
#else
    ::sdc::SessionException(__ice_what)
#endif
{
}

sdc::MessageException::~MessageException() throw()
{
}

static const char* __sdc__MessageException_name = "sdc::MessageException";

::std::string
sdc::MessageException::ice_name() const
{
    return __sdc__MessageException_name;
}

::Ice::Exception*
sdc::MessageException::ice_clone() const
{
    return new MessageException(*this);
}

void
sdc::MessageException::ice_throw() const
{
    throw *this;
}

void
sdc::MessageException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::sdc::MessageException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__write(__os);
#else
    ::sdc::SessionException::__write(__os);
#endif
}

void
sdc::MessageException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__read(__is, true);
#else
    ::sdc::SessionException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::MessageException::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(::std::string("::sdc::MessageException"));
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__write(__outS);
#else
    ::sdc::SessionException::__write(__outS);
#endif
}

void
sdc::MessageException::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        std::string s;
        __inS->read(s);
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__read(__inS, true);
#else
    ::sdc::SessionException::__read(__inS, true);
#endif
}
#endif

struct __F__sdc__MessageException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::sdc::MessageException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__sdc__MessageException__Ptr = new __F__sdc__MessageException;

const ::IceInternal::UserExceptionFactoryPtr&
sdc::MessageException::ice_factory()
{
    return __F__sdc__MessageException__Ptr;
}

class __F__sdc__MessageException__Init
{
public:

    __F__sdc__MessageException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::sdc::MessageException", ::sdc::MessageException::ice_factory());
    }

    ~__F__sdc__MessageException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::sdc::MessageException");
    }
};

static __F__sdc__MessageException__Init __F__sdc__MessageException__i;

#ifdef __APPLE__
extern "C" { void __F__sdc__MessageException__initializer() {} }
#endif

sdc::LogException::LogException(const ::std::string& __ice_what) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException(__ice_what)
#else
    ::sdc::SessionException(__ice_what)
#endif
{
}

sdc::LogException::~LogException() throw()
{
}

static const char* __sdc__LogException_name = "sdc::LogException";

::std::string
sdc::LogException::ice_name() const
{
    return __sdc__LogException_name;
}

::Ice::Exception*
sdc::LogException::ice_clone() const
{
    return new LogException(*this);
}

void
sdc::LogException::ice_throw() const
{
    throw *this;
}

void
sdc::LogException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::sdc::LogException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__write(__os);
#else
    ::sdc::SessionException::__write(__os);
#endif
}

void
sdc::LogException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__read(__is, true);
#else
    ::sdc::SessionException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::LogException::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(::std::string("::sdc::LogException"));
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__write(__outS);
#else
    ::sdc::SessionException::__write(__outS);
#endif
}

void
sdc::LogException::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        std::string s;
        __inS->read(s);
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__read(__inS, true);
#else
    ::sdc::SessionException::__read(__inS, true);
#endif
}
#endif

struct __F__sdc__LogException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::sdc::LogException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__sdc__LogException__Ptr = new __F__sdc__LogException;

const ::IceInternal::UserExceptionFactoryPtr&
sdc::LogException::ice_factory()
{
    return __F__sdc__LogException__Ptr;
}

class __F__sdc__LogException__Init
{
public:

    __F__sdc__LogException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::sdc::LogException", ::sdc::LogException::ice_factory());
    }

    ~__F__sdc__LogException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::sdc::LogException");
    }
};

static __F__sdc__LogException__Init __F__sdc__LogException__i;

#ifdef __APPLE__
extern "C" { void __F__sdc__LogException__initializer() {} }
#endif

sdc::ContactException::ContactException(const ::std::string& __ice_what) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException(__ice_what)
#else
    ::sdc::SessionException(__ice_what)
#endif
{
}

sdc::ContactException::~ContactException() throw()
{
}

static const char* __sdc__ContactException_name = "sdc::ContactException";

::std::string
sdc::ContactException::ice_name() const
{
    return __sdc__ContactException_name;
}

::Ice::Exception*
sdc::ContactException::ice_clone() const
{
    return new ContactException(*this);
}

void
sdc::ContactException::ice_throw() const
{
    throw *this;
}

void
sdc::ContactException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::sdc::ContactException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__write(__os);
#else
    ::sdc::SessionException::__write(__os);
#endif
}

void
sdc::ContactException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__read(__is, true);
#else
    ::sdc::SessionException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ContactException::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(::std::string("::sdc::ContactException"));
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__write(__outS);
#else
    ::sdc::SessionException::__write(__outS);
#endif
}

void
sdc::ContactException::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        std::string s;
        __inS->read(s);
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SessionException::__read(__inS, true);
#else
    ::sdc::SessionException::__read(__inS, true);
#endif
}
#endif

struct __F__sdc__ContactException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::sdc::ContactException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__sdc__ContactException__Ptr = new __F__sdc__ContactException;

const ::IceInternal::UserExceptionFactoryPtr&
sdc::ContactException::ice_factory()
{
    return __F__sdc__ContactException__Ptr;
}

class __F__sdc__ContactException__Init
{
public:

    __F__sdc__ContactException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::sdc::ContactException", ::sdc::ContactException::ice_factory());
    }

    ~__F__sdc__ContactException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::sdc::ContactException");
    }
};

static __F__sdc__ContactException__Init __F__sdc__ContactException__i;

#ifdef __APPLE__
extern "C" { void __F__sdc__ContactException__initializer() {} }
#endif

sdc::ChatClientCallbackException::ChatClientCallbackException(const ::std::string& __ice_what) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException(__ice_what)
#else
    ::sdc::SDCException(__ice_what)
#endif
{
}

sdc::ChatClientCallbackException::~ChatClientCallbackException() throw()
{
}

static const char* __sdc__ChatClientCallbackException_name = "sdc::ChatClientCallbackException";

::std::string
sdc::ChatClientCallbackException::ice_name() const
{
    return __sdc__ChatClientCallbackException_name;
}

::Ice::Exception*
sdc::ChatClientCallbackException::ice_clone() const
{
    return new ChatClientCallbackException(*this);
}

void
sdc::ChatClientCallbackException::ice_throw() const
{
    throw *this;
}

void
sdc::ChatClientCallbackException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::sdc::ChatClientCallbackException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__write(__os);
#else
    ::sdc::SDCException::__write(__os);
#endif
}

void
sdc::ChatClientCallbackException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__read(__is, true);
#else
    ::sdc::SDCException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ChatClientCallbackException::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(::std::string("::sdc::ChatClientCallbackException"));
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__write(__outS);
#else
    ::sdc::SDCException::__write(__outS);
#endif
}

void
sdc::ChatClientCallbackException::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        std::string s;
        __inS->read(s);
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__read(__inS, true);
#else
    ::sdc::SDCException::__read(__inS, true);
#endif
}
#endif

struct __F__sdc__ChatClientCallbackException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::sdc::ChatClientCallbackException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__sdc__ChatClientCallbackException__Ptr = new __F__sdc__ChatClientCallbackException;

const ::IceInternal::UserExceptionFactoryPtr&
sdc::ChatClientCallbackException::ice_factory()
{
    return __F__sdc__ChatClientCallbackException__Ptr;
}

class __F__sdc__ChatClientCallbackException__Init
{
public:

    __F__sdc__ChatClientCallbackException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::sdc::ChatClientCallbackException", ::sdc::ChatClientCallbackException::ice_factory());
    }

    ~__F__sdc__ChatClientCallbackException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::sdc::ChatClientCallbackException");
    }
};

static __F__sdc__ChatClientCallbackException__Init __F__sdc__ChatClientCallbackException__i;

#ifdef __APPLE__
extern "C" { void __F__sdc__ChatClientCallbackException__initializer() {} }
#endif

sdc::ChatException::ChatException(const ::std::string& __ice_what) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException(__ice_what)
#else
    ::sdc::ChatClientCallbackException(__ice_what)
#endif
{
}

sdc::ChatException::~ChatException() throw()
{
}

static const char* __sdc__ChatException_name = "sdc::ChatException";

::std::string
sdc::ChatException::ice_name() const
{
    return __sdc__ChatException_name;
}

::Ice::Exception*
sdc::ChatException::ice_clone() const
{
    return new ChatException(*this);
}

void
sdc::ChatException::ice_throw() const
{
    throw *this;
}

void
sdc::ChatException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::sdc::ChatException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException::__write(__os);
#else
    ::sdc::ChatClientCallbackException::__write(__os);
#endif
}

void
sdc::ChatException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException::__read(__is, true);
#else
    ::sdc::ChatClientCallbackException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ChatException::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(::std::string("::sdc::ChatException"));
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException::__write(__outS);
#else
    ::sdc::ChatClientCallbackException::__write(__outS);
#endif
}

void
sdc::ChatException::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        std::string s;
        __inS->read(s);
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException::__read(__inS, true);
#else
    ::sdc::ChatClientCallbackException::__read(__inS, true);
#endif
}
#endif

struct __F__sdc__ChatException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::sdc::ChatException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__sdc__ChatException__Ptr = new __F__sdc__ChatException;

const ::IceInternal::UserExceptionFactoryPtr&
sdc::ChatException::ice_factory()
{
    return __F__sdc__ChatException__Ptr;
}

class __F__sdc__ChatException__Init
{
public:

    __F__sdc__ChatException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::sdc::ChatException", ::sdc::ChatException::ice_factory());
    }

    ~__F__sdc__ChatException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::sdc::ChatException");
    }
};

static __F__sdc__ChatException__Init __F__sdc__ChatException__i;

#ifdef __APPLE__
extern "C" { void __F__sdc__ChatException__initializer() {} }
#endif

sdc::ParticipationException::ParticipationException(const ::std::string& __ice_what) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException(__ice_what)
#else
    ::sdc::ChatClientCallbackException(__ice_what)
#endif
{
}

sdc::ParticipationException::~ParticipationException() throw()
{
}

static const char* __sdc__ParticipationException_name = "sdc::ParticipationException";

::std::string
sdc::ParticipationException::ice_name() const
{
    return __sdc__ParticipationException_name;
}

::Ice::Exception*
sdc::ParticipationException::ice_clone() const
{
    return new ParticipationException(*this);
}

void
sdc::ParticipationException::ice_throw() const
{
    throw *this;
}

void
sdc::ParticipationException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::sdc::ParticipationException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException::__write(__os);
#else
    ::sdc::ChatClientCallbackException::__write(__os);
#endif
}

void
sdc::ParticipationException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException::__read(__is, true);
#else
    ::sdc::ChatClientCallbackException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ParticipationException::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(::std::string("::sdc::ParticipationException"));
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException::__write(__outS);
#else
    ::sdc::ChatClientCallbackException::__write(__outS);
#endif
}

void
sdc::ParticipationException::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        std::string s;
        __inS->read(s);
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException::__read(__inS, true);
#else
    ::sdc::ChatClientCallbackException::__read(__inS, true);
#endif
}
#endif

struct __F__sdc__ParticipationException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::sdc::ParticipationException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__sdc__ParticipationException__Ptr = new __F__sdc__ParticipationException;

const ::IceInternal::UserExceptionFactoryPtr&
sdc::ParticipationException::ice_factory()
{
    return __F__sdc__ParticipationException__Ptr;
}

class __F__sdc__ParticipationException__Init
{
public:

    __F__sdc__ParticipationException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::sdc::ParticipationException", ::sdc::ParticipationException::ice_factory());
    }

    ~__F__sdc__ParticipationException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::sdc::ParticipationException");
    }
};

static __F__sdc__ParticipationException__Init __F__sdc__ParticipationException__i;

#ifdef __APPLE__
extern "C" { void __F__sdc__ParticipationException__initializer() {} }
#endif

sdc::MessageCallbackException::MessageCallbackException(const ::std::string& __ice_what) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException(__ice_what)
#else
    ::sdc::ChatClientCallbackException(__ice_what)
#endif
{
}

sdc::MessageCallbackException::~MessageCallbackException() throw()
{
}

static const char* __sdc__MessageCallbackException_name = "sdc::MessageCallbackException";

::std::string
sdc::MessageCallbackException::ice_name() const
{
    return __sdc__MessageCallbackException_name;
}

::Ice::Exception*
sdc::MessageCallbackException::ice_clone() const
{
    return new MessageCallbackException(*this);
}

void
sdc::MessageCallbackException::ice_throw() const
{
    throw *this;
}

void
sdc::MessageCallbackException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::sdc::MessageCallbackException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException::__write(__os);
#else
    ::sdc::ChatClientCallbackException::__write(__os);
#endif
}

void
sdc::MessageCallbackException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException::__read(__is, true);
#else
    ::sdc::ChatClientCallbackException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::MessageCallbackException::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(::std::string("::sdc::MessageCallbackException"));
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException::__write(__outS);
#else
    ::sdc::ChatClientCallbackException::__write(__outS);
#endif
}

void
sdc::MessageCallbackException::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        std::string s;
        __inS->read(s);
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    ChatClientCallbackException::__read(__inS, true);
#else
    ::sdc::ChatClientCallbackException::__read(__inS, true);
#endif
}
#endif

struct __F__sdc__MessageCallbackException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::sdc::MessageCallbackException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__sdc__MessageCallbackException__Ptr = new __F__sdc__MessageCallbackException;

const ::IceInternal::UserExceptionFactoryPtr&
sdc::MessageCallbackException::ice_factory()
{
    return __F__sdc__MessageCallbackException__Ptr;
}

class __F__sdc__MessageCallbackException__Init
{
public:

    __F__sdc__MessageCallbackException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::sdc::MessageCallbackException", ::sdc::MessageCallbackException::ice_factory());
    }

    ~__F__sdc__MessageCallbackException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::sdc::MessageCallbackException");
    }
};

static __F__sdc__MessageCallbackException__Init __F__sdc__MessageCallbackException__i;

#ifdef __APPLE__
extern "C" { void __F__sdc__MessageCallbackException__initializer() {} }
#endif

sdc::InterServerException::InterServerException(const ::std::string& __ice_what) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException(__ice_what)
#else
    ::sdc::SDCException(__ice_what)
#endif
{
}

sdc::InterServerException::~InterServerException() throw()
{
}

static const char* __sdc__InterServerException_name = "sdc::InterServerException";

::std::string
sdc::InterServerException::ice_name() const
{
    return __sdc__InterServerException_name;
}

::Ice::Exception*
sdc::InterServerException::ice_clone() const
{
    return new InterServerException(*this);
}

void
sdc::InterServerException::ice_throw() const
{
    throw *this;
}

void
sdc::InterServerException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::sdc::InterServerException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__write(__os);
#else
    ::sdc::SDCException::__write(__os);
#endif
}

void
sdc::InterServerException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__read(__is, true);
#else
    ::sdc::SDCException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::InterServerException::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(::std::string("::sdc::InterServerException"));
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__write(__outS);
#else
    ::sdc::SDCException::__write(__outS);
#endif
}

void
sdc::InterServerException::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        std::string s;
        __inS->read(s);
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    SDCException::__read(__inS, true);
#else
    ::sdc::SDCException::__read(__inS, true);
#endif
}
#endif

struct __F__sdc__InterServerException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::sdc::InterServerException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__sdc__InterServerException__Ptr = new __F__sdc__InterServerException;

const ::IceInternal::UserExceptionFactoryPtr&
sdc::InterServerException::ice_factory()
{
    return __F__sdc__InterServerException__Ptr;
}

class __F__sdc__InterServerException__Init
{
public:

    __F__sdc__InterServerException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::sdc::InterServerException", ::sdc::InterServerException::ice_factory());
    }

    ~__F__sdc__InterServerException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::sdc::InterServerException");
    }
};

static __F__sdc__InterServerException__Init __F__sdc__InterServerException__i;

#ifdef __APPLE__
extern "C" { void __F__sdc__InterServerException__initializer() {} }
#endif

void
sdc::User::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(ID);
    if(publicKey.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        __os->write(&publicKey[0], &publicKey[0] + publicKey.size());
    }
}

void
sdc::User::__read(::IceInternal::BasicStream* __is)
{
    __is->read(ID);
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ___publicKey;
    __is->read(___publicKey);
    ::std::vector< ::Ice::Byte>(___publicKey.first, ___publicKey.second).swap(publicKey);
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::User::ice_write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(ID);
    __outS->write(publicKey);
}

void
sdc::User::ice_read(const ::Ice::InputStreamPtr& __inS)
{
    __inS->read(ID);
    __inS->read(publicKey);
}
#endif

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ice_writeUser(const ::Ice::OutputStreamPtr& __outS, const ::sdc::User& __v)
{
    __v.ice_write(__outS);
}

void
sdc::ice_readUser(const ::Ice::InputStreamPtr& __inS, ::sdc::User& __v)
{
    __v.ice_read(__inS);
}
#endif

void
sdc::__writeContactList(::IceInternal::BasicStream* __os, const ::sdc::User* begin, const ::sdc::User* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
sdc::__readContactList(::IceInternal::BasicStream* __is, ::sdc::ContactList& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(2, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ice_writeContactList(const ::Ice::OutputStreamPtr& __outS, const ::sdc::ContactList& v)
{
    __outS->writeSize(::Ice::Int(v.size()));
    ::sdc::ContactList::const_iterator p;
    for(p = v.begin(); p != v.end(); ++p)
    {
        __outS->write((*p));
    }
}

void
sdc::ice_readContactList(const ::Ice::InputStreamPtr& __inS, ::sdc::ContactList& v)
{
    ::Ice::Int sz = __inS->readAndCheckSeqSize(2);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        __inS->read(v[i]);
    }
}
#endif

void
sdc::LogMessage::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(senderID);
    __os->write(timestamp);
    __os->write(message);
}

void
sdc::LogMessage::__read(::IceInternal::BasicStream* __is)
{
    __is->read(senderID);
    __is->read(timestamp);
    __is->read(message);
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::LogMessage::ice_write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(senderID);
    __outS->write(timestamp);
    __outS->write(message);
}

void
sdc::LogMessage::ice_read(const ::Ice::InputStreamPtr& __inS)
{
    __inS->read(senderID);
    __inS->read(timestamp);
    __inS->read(message);
}
#endif

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ice_writeLogMessage(const ::Ice::OutputStreamPtr& __outS, const ::sdc::LogMessage& __v)
{
    __v.ice_write(__outS);
}

void
sdc::ice_readLogMessage(const ::Ice::InputStreamPtr& __inS, ::sdc::LogMessage& __v)
{
    __v.ice_read(__inS);
}
#endif

void
sdc::__writeChatlog(::IceInternal::BasicStream* __os, const ::sdc::LogMessage* begin, const ::sdc::LogMessage* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
sdc::__readChatlog(::IceInternal::BasicStream* __is, ::sdc::Chatlog& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(10, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ice_writeChatlog(const ::Ice::OutputStreamPtr& __outS, const ::sdc::Chatlog& v)
{
    __outS->writeSize(::Ice::Int(v.size()));
    ::sdc::Chatlog::const_iterator p;
    for(p = v.begin(); p != v.end(); ++p)
    {
        __outS->write((*p));
    }
}

void
sdc::ice_readChatlog(const ::Ice::InputStreamPtr& __inS, ::sdc::Chatlog& v)
{
    ::Ice::Int sz = __inS->readAndCheckSeqSize(10);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        __inS->read(v[i]);
    }
}
#endif

void
sdc::ChatlogEntry::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(chatID);
    __os->write(timestamp);
}

void
sdc::ChatlogEntry::__read(::IceInternal::BasicStream* __is)
{
    __is->read(chatID);
    __is->read(timestamp);
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ChatlogEntry::ice_write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(chatID);
    __outS->write(timestamp);
}

void
sdc::ChatlogEntry::ice_read(const ::Ice::InputStreamPtr& __inS)
{
    __inS->read(chatID);
    __inS->read(timestamp);
}
#endif

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ice_writeChatlogEntry(const ::Ice::OutputStreamPtr& __outS, const ::sdc::ChatlogEntry& __v)
{
    __v.ice_write(__outS);
}

void
sdc::ice_readChatlogEntry(const ::Ice::InputStreamPtr& __inS, ::sdc::ChatlogEntry& __v)
{
    __v.ice_read(__inS);
}
#endif

void
sdc::__writeLoglist(::IceInternal::BasicStream* __os, const ::sdc::ChatlogEntry* begin, const ::sdc::ChatlogEntry* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
sdc::__readLoglist(::IceInternal::BasicStream* __is, ::sdc::Loglist& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(9, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ice_writeLoglist(const ::Ice::OutputStreamPtr& __outS, const ::sdc::Loglist& v)
{
    __outS->writeSize(::Ice::Int(v.size()));
    ::sdc::Loglist::const_iterator p;
    for(p = v.begin(); p != v.end(); ++p)
    {
        __outS->write((*p));
    }
}

void
sdc::ice_readLoglist(const ::Ice::InputStreamPtr& __inS, ::sdc::Loglist& v)
{
    ::Ice::Int sz = __inS->readAndCheckSeqSize(9);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        __inS->read(v[i]);
    }
}
#endif

void
sdc::SecureContainer::__write(::IceInternal::BasicStream* __os) const
{
    if(data.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        __os->write(&data[0], &data[0] + data.size());
    }
    if(signature.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        __os->write(&signature[0], &signature[0] + signature.size());
    }
}

void
sdc::SecureContainer::__read(::IceInternal::BasicStream* __is)
{
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ___data;
    __is->read(___data);
    ::std::vector< ::Ice::Byte>(___data.first, ___data.second).swap(data);
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ___signature;
    __is->read(___signature);
    ::std::vector< ::Ice::Byte>(___signature.first, ___signature.second).swap(signature);
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::SecureContainer::ice_write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->write(data);
    __outS->write(signature);
}

void
sdc::SecureContainer::ice_read(const ::Ice::InputStreamPtr& __inS)
{
    __inS->read(data);
    __inS->read(signature);
}
#endif

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ice_writeSecureContainer(const ::Ice::OutputStreamPtr& __outS, const ::sdc::SecureContainer& __v)
{
    __v.ice_write(__outS);
}

void
sdc::ice_readSecureContainer(const ::Ice::InputStreamPtr& __inS, ::sdc::SecureContainer& __v)
{
    __v.ice_read(__inS);
}
#endif

void
IceProxy::sdc::SessionI::logout(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__SessionI__logout_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::SessionI* __del = dynamic_cast< ::IceDelegate::sdc::SessionI*>(__delBase.get());
            __del->logout(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::SessionI::begin_logout(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__SessionI__logout_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__SessionI__logout_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__SessionI__logout_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::SessionI::end_logout(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__SessionI__logout_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::UserHandlingException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

::sdc::User
IceProxy::sdc::SessionI::retrieveUser(const ::std::string& userID, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__SessionI__retrieveUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::SessionI* __del = dynamic_cast< ::IceDelegate::sdc::SessionI*>(__delBase.get());
            return __del->retrieveUser(userID, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::SessionI::begin_retrieveUser(const ::std::string& userID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__SessionI__retrieveUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__SessionI__retrieveUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__SessionI__retrieveUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(userID);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::sdc::User
IceProxy::sdc::SessionI::end_retrieveUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__SessionI__retrieveUser_name);
    ::sdc::User __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::InterServerException&)
        {
            throw;
        }
        catch(const ::sdc::UserHandlingException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __ret.__read(__is);
    __is->endReadEncaps();
    return __ret;
}

::std::string
IceProxy::sdc::SessionI::initChat(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__SessionI__initChat_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::SessionI* __del = dynamic_cast< ::IceDelegate::sdc::SessionI*>(__delBase.get());
            return __del->initChat(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::SessionI::begin_initChat(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__SessionI__initChat_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__SessionI__initChat_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__SessionI__initChat_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::sdc::SessionI::end_initChat(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__SessionI__initChat_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::SessionException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::sdc::SessionI::leaveChat(const ::std::string& chatID, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__SessionI__leaveChat_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::SessionI* __del = dynamic_cast< ::IceDelegate::sdc::SessionI*>(__delBase.get());
            __del->leaveChat(chatID, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::SessionI::begin_leaveChat(const ::std::string& chatID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__SessionI__leaveChat_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__SessionI__leaveChat_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__SessionI__leaveChat_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(chatID);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::SessionI::end_leaveChat(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__SessionI__leaveChat_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::InterServerException&)
        {
            throw;
        }
        catch(const ::sdc::SessionException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::SessionI::invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__SessionI__invite_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::SessionI* __del = dynamic_cast< ::IceDelegate::sdc::SessionI*>(__delBase.get());
            __del->invite(participant, chatID, sessionKey, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::SessionI::begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__SessionI__invite_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__SessionI__invite_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__SessionI__invite_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        participant.__write(__os);
        __os->write(chatID);
        if(sessionKey.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&sessionKey[0], &sessionKey[0] + sessionKey.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::SessionI::end_invite(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__SessionI__invite_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::InterServerException&)
        {
            throw;
        }
        catch(const ::sdc::UserHandlingException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::SessionI::sendMessage(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__SessionI__sendMessage_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::SessionI* __del = dynamic_cast< ::IceDelegate::sdc::SessionI*>(__delBase.get());
            __del->sendMessage(message, chatID, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::SessionI::begin_sendMessage(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__SessionI__sendMessage_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__SessionI__sendMessage_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__SessionI__sendMessage_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(message.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&message[0], &message[0] + message.size());
        }
        __os->write(chatID);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::SessionI::end_sendMessage(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__SessionI__sendMessage_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::InterServerException&)
        {
            throw;
        }
        catch(const ::sdc::MessageException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::SessionI::deleteUser(const ::sdc::User& participant, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__SessionI__deleteUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::SessionI* __del = dynamic_cast< ::IceDelegate::sdc::SessionI*>(__delBase.get());
            __del->deleteUser(participant, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::SessionI::begin_deleteUser(const ::sdc::User& participant, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__SessionI__deleteUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__SessionI__deleteUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__SessionI__deleteUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        participant.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::SessionI::end_deleteUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__SessionI__deleteUser_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::UserHandlingException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::SessionI::saveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__SessionI__saveLog_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::SessionI* __del = dynamic_cast< ::IceDelegate::sdc::SessionI*>(__delBase.get());
            __del->saveLog(chatID, timestamp, log, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::SessionI::begin_saveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__SessionI__saveLog_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__SessionI__saveLog_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__SessionI__saveLog_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(chatID);
        __os->write(timestamp);
        log.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::SessionI::end_saveLog(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__SessionI__saveLog_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::LogException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

::sdc::Loglist
IceProxy::sdc::SessionI::retrieveLoglist(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__SessionI__retrieveLoglist_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::SessionI* __del = dynamic_cast< ::IceDelegate::sdc::SessionI*>(__delBase.get());
            return __del->retrieveLoglist(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::SessionI::begin_retrieveLoglist(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__SessionI__retrieveLoglist_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__SessionI__retrieveLoglist_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__SessionI__retrieveLoglist_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::sdc::Loglist
IceProxy::sdc::SessionI::end_retrieveLoglist(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__SessionI__retrieveLoglist_name);
    ::sdc::Loglist __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::LogException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::sdc::__readLoglist(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

::sdc::SecureContainer
IceProxy::sdc::SessionI::retrieveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__SessionI__retrieveLog_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::SessionI* __del = dynamic_cast< ::IceDelegate::sdc::SessionI*>(__delBase.get());
            return __del->retrieveLog(chatID, timestamp, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::SessionI::begin_retrieveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__SessionI__retrieveLog_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__SessionI__retrieveLog_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__SessionI__retrieveLog_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(chatID);
        __os->write(timestamp);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::sdc::SecureContainer
IceProxy::sdc::SessionI::end_retrieveLog(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__SessionI__retrieveLog_name);
    ::sdc::SecureContainer __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::LogException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __ret.__read(__is);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::sdc::SessionI::saveContactList(const ::sdc::SecureContainer& contactList, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__SessionI__saveContactList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::SessionI* __del = dynamic_cast< ::IceDelegate::sdc::SessionI*>(__delBase.get());
            __del->saveContactList(contactList, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::SessionI::begin_saveContactList(const ::sdc::SecureContainer& contactList, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__SessionI__saveContactList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__SessionI__saveContactList_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__SessionI__saveContactList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        contactList.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::SessionI::end_saveContactList(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__SessionI__saveContactList_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::ContactException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

::sdc::SecureContainer
IceProxy::sdc::SessionI::retrieveContactList(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__SessionI__retrieveContactList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::SessionI* __del = dynamic_cast< ::IceDelegate::sdc::SessionI*>(__delBase.get());
            return __del->retrieveContactList(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::SessionI::begin_retrieveContactList(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__SessionI__retrieveContactList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__SessionI__retrieveContactList_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__SessionI__retrieveContactList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::sdc::SecureContainer
IceProxy::sdc::SessionI::end_retrieveContactList(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__SessionI__retrieveContactList_name);
    ::sdc::SecureContainer __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::ContactException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __ret.__read(__is);
    __is->endReadEncaps();
    return __ret;
}

const ::std::string&
IceProxy::sdc::SessionI::ice_staticId()
{
    return ::sdc::SessionI::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::sdc::SessionI::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::sdc::SessionI);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::sdc::SessionI::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::sdc::SessionI);
}

::IceProxy::Ice::Object*
IceProxy::sdc::SessionI::__newInstance() const
{
    return new SessionI;
}

void
IceProxy::sdc::AuthenticationI::registerUser(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__AuthenticationI__registerUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::AuthenticationI* __del = dynamic_cast< ::IceDelegate::sdc::AuthenticationI*>(__delBase.get());
            __del->registerUser(participant, pwd, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::AuthenticationI::begin_registerUser(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__AuthenticationI__registerUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__AuthenticationI__registerUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__AuthenticationI__registerUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        participant.__write(__os);
        __os->write(pwd);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::AuthenticationI::end_registerUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__AuthenticationI__registerUser_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::AuthenticationException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

::sdc::SessionIPrx
IceProxy::sdc::AuthenticationI::login(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__AuthenticationI__login_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::AuthenticationI* __del = dynamic_cast< ::IceDelegate::sdc::AuthenticationI*>(__delBase.get());
            return __del->login(participant, pwd, ident, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::AuthenticationI::begin_login(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__AuthenticationI__login_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__AuthenticationI__login_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__AuthenticationI__login_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        participant.__write(__os);
        __os->write(pwd);
        ident.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::sdc::SessionIPrx
IceProxy::sdc::AuthenticationI::end_login(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__AuthenticationI__login_name);
    ::sdc::SessionIPrx __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::AuthenticationException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::sdc::__read(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

::std::string
IceProxy::sdc::AuthenticationI::echo(const ::std::string& message, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__AuthenticationI__echo_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::AuthenticationI* __del = dynamic_cast< ::IceDelegate::sdc::AuthenticationI*>(__delBase.get());
            return __del->echo(message, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::AuthenticationI::begin_echo(const ::std::string& message, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__AuthenticationI__echo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__AuthenticationI__echo_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__AuthenticationI__echo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(message);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::sdc::AuthenticationI::end_echo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__AuthenticationI__echo_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::SDCException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

const ::std::string&
IceProxy::sdc::AuthenticationI::ice_staticId()
{
    return ::sdc::AuthenticationI::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::sdc::AuthenticationI::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::sdc::AuthenticationI);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::sdc::AuthenticationI::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::sdc::AuthenticationI);
}

::IceProxy::Ice::Object*
IceProxy::sdc::AuthenticationI::__newInstance() const
{
    return new AuthenticationI;
}

void
IceProxy::sdc::ChatClientCallbackI::initChat(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__ChatClientCallbackI__initChat_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::ChatClientCallbackI* __del = dynamic_cast< ::IceDelegate::sdc::ChatClientCallbackI*>(__delBase.get());
            __del->initChat(users, chatID, key, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::ChatClientCallbackI::begin_initChat(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__ChatClientCallbackI__initChat_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__ChatClientCallbackI__initChat_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__ChatClientCallbackI__initChat_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(users.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&users[0], &users[0] + users.size());
        }
        __os->write(chatID);
        if(key.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&key[0], &key[0] + key.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::ChatClientCallbackI::end_initChat(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__ChatClientCallbackI__initChat_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::ChatException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::ChatClientCallbackI::addChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__ChatClientCallbackI__addChatParticipant_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::ChatClientCallbackI* __del = dynamic_cast< ::IceDelegate::sdc::ChatClientCallbackI*>(__delBase.get());
            __del->addChatParticipant(participant, chatID, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::ChatClientCallbackI::begin_addChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__ChatClientCallbackI__addChatParticipant_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__ChatClientCallbackI__addChatParticipant_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__ChatClientCallbackI__addChatParticipant_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        participant.__write(__os);
        __os->write(chatID);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::ChatClientCallbackI::end_addChatParticipant(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__ChatClientCallbackI__addChatParticipant_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::ParticipationException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::ChatClientCallbackI::removeChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__ChatClientCallbackI__removeChatParticipant_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::ChatClientCallbackI* __del = dynamic_cast< ::IceDelegate::sdc::ChatClientCallbackI*>(__delBase.get());
            __del->removeChatParticipant(participant, chatID, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::ChatClientCallbackI::begin_removeChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__ChatClientCallbackI__removeChatParticipant_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__ChatClientCallbackI__removeChatParticipant_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__ChatClientCallbackI__removeChatParticipant_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        participant.__write(__os);
        __os->write(chatID);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::ChatClientCallbackI::end_removeChatParticipant(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__ChatClientCallbackI__removeChatParticipant_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::ParticipationException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::ChatClientCallbackI::appendMessageToChat(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__ChatClientCallbackI__appendMessageToChat_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::ChatClientCallbackI* __del = dynamic_cast< ::IceDelegate::sdc::ChatClientCallbackI*>(__delBase.get());
            __del->appendMessageToChat(message, chatID, participant, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::ChatClientCallbackI::begin_appendMessageToChat(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__ChatClientCallbackI__appendMessageToChat_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__ChatClientCallbackI__appendMessageToChat_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__ChatClientCallbackI__appendMessageToChat_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(message.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&message[0], &message[0] + message.size());
        }
        __os->write(chatID);
        participant.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::ChatClientCallbackI::end_appendMessageToChat(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__ChatClientCallbackI__appendMessageToChat_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::MessageCallbackException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

::std::string
IceProxy::sdc::ChatClientCallbackI::echo(const ::std::string& message, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__ChatClientCallbackI__echo_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::ChatClientCallbackI* __del = dynamic_cast< ::IceDelegate::sdc::ChatClientCallbackI*>(__delBase.get());
            return __del->echo(message, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::ChatClientCallbackI::begin_echo(const ::std::string& message, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__ChatClientCallbackI__echo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__ChatClientCallbackI__echo_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__ChatClientCallbackI__echo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(message);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::sdc::ChatClientCallbackI::end_echo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__ChatClientCallbackI__echo_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::SDCException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

const ::std::string&
IceProxy::sdc::ChatClientCallbackI::ice_staticId()
{
    return ::sdc::ChatClientCallbackI::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::sdc::ChatClientCallbackI::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::sdc::ChatClientCallbackI);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::sdc::ChatClientCallbackI::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::sdc::ChatClientCallbackI);
}

::IceProxy::Ice::Object*
IceProxy::sdc::ChatClientCallbackI::__newInstance() const
{
    return new ChatClientCallbackI;
}

::sdc::User
IceProxy::sdc::InterServerI::retrieveUser(const ::std::string& userID, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__InterServerI__retrieveUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::InterServerI* __del = dynamic_cast< ::IceDelegate::sdc::InterServerI*>(__delBase.get());
            return __del->retrieveUser(userID, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::InterServerI::begin_retrieveUser(const ::std::string& userID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__InterServerI__retrieveUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__InterServerI__retrieveUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__InterServerI__retrieveUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(userID);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::sdc::User
IceProxy::sdc::InterServerI::end_retrieveUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__InterServerI__retrieveUser_name);
    ::sdc::User __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::InterServerException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __ret.__read(__is);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::sdc::InterServerI::invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__InterServerI__invite_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::InterServerI* __del = dynamic_cast< ::IceDelegate::sdc::InterServerI*>(__delBase.get());
            __del->invite(participant, chatID, key, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::InterServerI::begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__InterServerI__invite_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__InterServerI__invite_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__InterServerI__invite_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        participant.__write(__os);
        __os->write(chatID);
        if(key.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&key[0], &key[0] + key.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::InterServerI::end_invite(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__InterServerI__invite_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::InterServerException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::InterServerI::sendMessage(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__InterServerI__sendMessage_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::InterServerI* __del = dynamic_cast< ::IceDelegate::sdc::InterServerI*>(__delBase.get());
            __del->sendMessage(sender, message, chatID, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::InterServerI::begin_sendMessage(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__InterServerI__sendMessage_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__InterServerI__sendMessage_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__InterServerI__sendMessage_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        sender.__write(__os);
        if(message.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&message[0], &message[0] + message.size());
        }
        __os->write(chatID);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::InterServerI::end_sendMessage(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__InterServerI__sendMessage_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::InterServerException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::InterServerI::leaveChat(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__InterServerI__leaveChat_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::InterServerI* __del = dynamic_cast< ::IceDelegate::sdc::InterServerI*>(__delBase.get());
            __del->leaveChat(participant, chatID, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::InterServerI::begin_leaveChat(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__InterServerI__leaveChat_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__InterServerI__leaveChat_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__InterServerI__leaveChat_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        participant.__write(__os);
        __os->write(chatID);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::InterServerI::end_leaveChat(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__InterServerI__leaveChat_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::InterServerException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::InterServerI::clientInitChat(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__InterServerI__clientInitChat_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::InterServerI* __del = dynamic_cast< ::IceDelegate::sdc::InterServerI*>(__delBase.get());
            __del->clientInitChat(client, users, chatID, key, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::InterServerI::begin_clientInitChat(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__InterServerI__clientInitChat_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__InterServerI__clientInitChat_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__InterServerI__clientInitChat_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        client.__write(__os);
        if(users.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&users[0], &users[0] + users.size());
        }
        __os->write(chatID);
        if(key.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&key[0], &key[0] + key.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::InterServerI::end_clientInitChat(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__InterServerI__clientInitChat_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::ChatException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::InterServerI::clientAddChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__InterServerI__clientAddChatParticipant_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::InterServerI* __del = dynamic_cast< ::IceDelegate::sdc::InterServerI*>(__delBase.get());
            __del->clientAddChatParticipant(client, participant, chatID, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::InterServerI::begin_clientAddChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__InterServerI__clientAddChatParticipant_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__InterServerI__clientAddChatParticipant_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__InterServerI__clientAddChatParticipant_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        client.__write(__os);
        participant.__write(__os);
        __os->write(chatID);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::InterServerI::end_clientAddChatParticipant(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__InterServerI__clientAddChatParticipant_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::ParticipationException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::InterServerI::clientRemoveChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__InterServerI__clientRemoveChatParticipant_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::InterServerI* __del = dynamic_cast< ::IceDelegate::sdc::InterServerI*>(__delBase.get());
            __del->clientRemoveChatParticipant(client, participant, chatID, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::InterServerI::begin_clientRemoveChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__InterServerI__clientRemoveChatParticipant_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__InterServerI__clientRemoveChatParticipant_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__InterServerI__clientRemoveChatParticipant_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        client.__write(__os);
        participant.__write(__os);
        __os->write(chatID);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::InterServerI::end_clientRemoveChatParticipant(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__InterServerI__clientRemoveChatParticipant_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::ParticipationException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::sdc::InterServerI::clientAppendMessageToChat(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__sdc__InterServerI__clientAppendMessageToChat_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::sdc::InterServerI* __del = dynamic_cast< ::IceDelegate::sdc::InterServerI*>(__delBase.get());
            __del->clientAppendMessageToChat(client, message, chatID, participant, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::sdc::InterServerI::begin_clientAppendMessageToChat(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__sdc__InterServerI__clientAppendMessageToChat_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __sdc__InterServerI__clientAppendMessageToChat_name, __del, __cookie);
    try
    {
        __result->__prepare(__sdc__InterServerI__clientAppendMessageToChat_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        client.__write(__os);
        if(message.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&message[0], &message[0] + message.size());
        }
        __os->write(chatID);
        participant.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::sdc::InterServerI::end_clientAppendMessageToChat(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __sdc__InterServerI__clientAppendMessageToChat_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::sdc::MessageCallbackException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

const ::std::string&
IceProxy::sdc::InterServerI::ice_staticId()
{
    return ::sdc::InterServerI::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::sdc::InterServerI::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::sdc::InterServerI);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::sdc::InterServerI::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::sdc::InterServerI);
}

::IceProxy::Ice::Object*
IceProxy::sdc::InterServerI::__newInstance() const
{
    return new InterServerI;
}

void
IceDelegateM::sdc::SessionI::logout(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__SessionI__logout_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::UserHandlingException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::sdc::User
IceDelegateM::sdc::SessionI::retrieveUser(const ::std::string& userID, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__SessionI__retrieveUser_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(userID);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::sdc::User __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::InterServerException&)
            {
                throw;
            }
            catch(const ::sdc::UserHandlingException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __ret.__read(__is);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::sdc::SessionI::initChat(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__SessionI__initChat_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::SessionException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::SessionI::leaveChat(const ::std::string& chatID, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__SessionI__leaveChat_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(chatID);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::InterServerException&)
            {
                throw;
            }
            catch(const ::sdc::SessionException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::SessionI::invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__SessionI__invite_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        participant.__write(__os);
        __os->write(chatID);
        if(sessionKey.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&sessionKey[0], &sessionKey[0] + sessionKey.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::InterServerException&)
            {
                throw;
            }
            catch(const ::sdc::UserHandlingException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::SessionI::sendMessage(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__SessionI__sendMessage_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(message.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&message[0], &message[0] + message.size());
        }
        __os->write(chatID);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::InterServerException&)
            {
                throw;
            }
            catch(const ::sdc::MessageException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::SessionI::deleteUser(const ::sdc::User& participant, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__SessionI__deleteUser_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        participant.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::UserHandlingException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::SessionI::saveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__SessionI__saveLog_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(chatID);
        __os->write(timestamp);
        log.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::LogException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::sdc::Loglist
IceDelegateM::sdc::SessionI::retrieveLoglist(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__SessionI__retrieveLoglist_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::sdc::Loglist __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::LogException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::sdc::__readLoglist(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::sdc::SecureContainer
IceDelegateM::sdc::SessionI::retrieveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__SessionI__retrieveLog_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(chatID);
        __os->write(timestamp);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::sdc::SecureContainer __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::LogException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __ret.__read(__is);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::SessionI::saveContactList(const ::sdc::SecureContainer& contactList, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__SessionI__saveContactList_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        contactList.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::ContactException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::sdc::SecureContainer
IceDelegateM::sdc::SessionI::retrieveContactList(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__SessionI__retrieveContactList_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::sdc::SecureContainer __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::ContactException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __ret.__read(__is);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::AuthenticationI::registerUser(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__AuthenticationI__registerUser_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        participant.__write(__os);
        __os->write(pwd);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::AuthenticationException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::sdc::SessionIPrx
IceDelegateM::sdc::AuthenticationI::login(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__AuthenticationI__login_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        participant.__write(__os);
        __os->write(pwd);
        ident.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::sdc::SessionIPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::AuthenticationException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::sdc::__read(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::sdc::AuthenticationI::echo(const ::std::string& message, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__AuthenticationI__echo_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(message);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::SDCException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::ChatClientCallbackI::initChat(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__ChatClientCallbackI__initChat_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(users.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&users[0], &users[0] + users.size());
        }
        __os->write(chatID);
        if(key.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&key[0], &key[0] + key.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::ChatException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::ChatClientCallbackI::addChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__ChatClientCallbackI__addChatParticipant_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        participant.__write(__os);
        __os->write(chatID);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::ParticipationException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::ChatClientCallbackI::removeChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__ChatClientCallbackI__removeChatParticipant_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        participant.__write(__os);
        __os->write(chatID);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::ParticipationException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::ChatClientCallbackI::appendMessageToChat(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__ChatClientCallbackI__appendMessageToChat_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(message.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&message[0], &message[0] + message.size());
        }
        __os->write(chatID);
        participant.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::MessageCallbackException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::sdc::ChatClientCallbackI::echo(const ::std::string& message, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__ChatClientCallbackI__echo_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(message);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::SDCException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::sdc::User
IceDelegateM::sdc::InterServerI::retrieveUser(const ::std::string& userID, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__InterServerI__retrieveUser_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(userID);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::sdc::User __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::InterServerException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __ret.__read(__is);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::InterServerI::invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__InterServerI__invite_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        participant.__write(__os);
        __os->write(chatID);
        if(key.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&key[0], &key[0] + key.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::InterServerException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::InterServerI::sendMessage(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__InterServerI__sendMessage_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        sender.__write(__os);
        if(message.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&message[0], &message[0] + message.size());
        }
        __os->write(chatID);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::InterServerException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::InterServerI::leaveChat(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__InterServerI__leaveChat_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        participant.__write(__os);
        __os->write(chatID);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::InterServerException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::InterServerI::clientInitChat(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__InterServerI__clientInitChat_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        client.__write(__os);
        if(users.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&users[0], &users[0] + users.size());
        }
        __os->write(chatID);
        if(key.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&key[0], &key[0] + key.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::ChatException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::InterServerI::clientAddChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__InterServerI__clientAddChatParticipant_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        client.__write(__os);
        participant.__write(__os);
        __os->write(chatID);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::ParticipationException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::InterServerI::clientRemoveChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__InterServerI__clientRemoveChatParticipant_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        client.__write(__os);
        participant.__write(__os);
        __os->write(chatID);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::ParticipationException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::sdc::InterServerI::clientAppendMessageToChat(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __sdc__InterServerI__clientAppendMessageToChat_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        client.__write(__os);
        if(message.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&message[0], &message[0] + message.size());
        }
        __os->write(chatID);
        participant.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::sdc::MessageCallbackException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateD::sdc::SessionI::logout(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::SessionI* servant = dynamic_cast< ::sdc::SessionI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->logout(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__SessionI__logout_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::UserHandlingException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::sdc::User
IceDelegateD::sdc::SessionI::retrieveUser(const ::std::string& userID, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::sdc::User& __result, const ::std::string& userID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_userID(userID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::SessionI* servant = dynamic_cast< ::sdc::SessionI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->retrieveUser(_m_userID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::sdc::User& _result;
        const ::std::string& _m_userID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__SessionI__retrieveUser_name, ::Ice::Normal, __context);
    ::sdc::User __result;
    try
    {
        _DirectI __direct(__result, userID, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::InterServerException&)
    {
        throw;
    }
    catch(const ::sdc::UserHandlingException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::std::string
IceDelegateD::sdc::SessionI::initChat(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::SessionI* servant = dynamic_cast< ::sdc::SessionI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->initChat(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__SessionI__initChat_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::SessionException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::sdc::SessionI::leaveChat(const ::std::string& chatID, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& chatID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_chatID(chatID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::SessionI* servant = dynamic_cast< ::sdc::SessionI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->leaveChat(_m_chatID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::std::string& _m_chatID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__SessionI__leaveChat_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(chatID, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::InterServerException&)
    {
        throw;
    }
    catch(const ::sdc::SessionException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::SessionI::invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_participant(participant),
            _m_chatID(chatID),
            _m_sessionKey(sessionKey)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::SessionI* servant = dynamic_cast< ::sdc::SessionI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->invite(_m_participant, _m_chatID, _m_sessionKey, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::User& _m_participant;
        const ::std::string& _m_chatID;
        const ::sdc::ByteSeq& _m_sessionKey;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__SessionI__invite_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(participant, chatID, sessionKey, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::InterServerException&)
    {
        throw;
    }
    catch(const ::sdc::UserHandlingException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::SessionI::sendMessage(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_message(message),
            _m_chatID(chatID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::SessionI* servant = dynamic_cast< ::sdc::SessionI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->sendMessage(_m_message, _m_chatID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::ByteSeq& _m_message;
        const ::std::string& _m_chatID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__SessionI__sendMessage_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(message, chatID, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::InterServerException&)
    {
        throw;
    }
    catch(const ::sdc::MessageException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::SessionI::deleteUser(const ::sdc::User& participant, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::User& participant, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_participant(participant)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::SessionI* servant = dynamic_cast< ::sdc::SessionI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->deleteUser(_m_participant, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::User& _m_participant;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__SessionI__deleteUser_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(participant, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::UserHandlingException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::SessionI::saveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_chatID(chatID),
            _m_timestamp(timestamp),
            _m_log(log)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::SessionI* servant = dynamic_cast< ::sdc::SessionI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->saveLog(_m_chatID, _m_timestamp, _m_log, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::std::string& _m_chatID;
        ::Ice::Long _m_timestamp;
        const ::sdc::SecureContainer& _m_log;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__SessionI__saveLog_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(chatID, timestamp, log, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::LogException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::sdc::Loglist
IceDelegateD::sdc::SessionI::retrieveLoglist(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::sdc::Loglist& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::SessionI* servant = dynamic_cast< ::sdc::SessionI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->retrieveLoglist(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::sdc::Loglist& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__SessionI__retrieveLoglist_name, ::Ice::Normal, __context);
    ::sdc::Loglist __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::LogException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::sdc::SecureContainer
IceDelegateD::sdc::SessionI::retrieveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::sdc::SecureContainer& __result, const ::std::string& chatID, ::Ice::Long timestamp, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_chatID(chatID),
            _m_timestamp(timestamp)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::SessionI* servant = dynamic_cast< ::sdc::SessionI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->retrieveLog(_m_chatID, _m_timestamp, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::sdc::SecureContainer& _result;
        const ::std::string& _m_chatID;
        ::Ice::Long _m_timestamp;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__SessionI__retrieveLog_name, ::Ice::Normal, __context);
    ::sdc::SecureContainer __result;
    try
    {
        _DirectI __direct(__result, chatID, timestamp, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::LogException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::sdc::SessionI::saveContactList(const ::sdc::SecureContainer& contactList, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::SecureContainer& contactList, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_contactList(contactList)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::SessionI* servant = dynamic_cast< ::sdc::SessionI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->saveContactList(_m_contactList, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::SecureContainer& _m_contactList;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__SessionI__saveContactList_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(contactList, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::ContactException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::sdc::SecureContainer
IceDelegateD::sdc::SessionI::retrieveContactList(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::sdc::SecureContainer& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::SessionI* servant = dynamic_cast< ::sdc::SessionI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->retrieveContactList(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::sdc::SecureContainer& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__SessionI__retrieveContactList_name, ::Ice::Normal, __context);
    ::sdc::SecureContainer __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::ContactException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::sdc::AuthenticationI::registerUser(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_participant(participant),
            _m_pwd(pwd)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::AuthenticationI* servant = dynamic_cast< ::sdc::AuthenticationI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->registerUser(_m_participant, _m_pwd, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::User& _m_participant;
        const ::std::string& _m_pwd;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__AuthenticationI__registerUser_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(participant, pwd, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::AuthenticationException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::sdc::SessionIPrx
IceDelegateD::sdc::AuthenticationI::login(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::sdc::SessionIPrx& __result, const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_participant(participant),
            _m_pwd(pwd),
            _m_ident(ident)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::AuthenticationI* servant = dynamic_cast< ::sdc::AuthenticationI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->login(_m_participant, _m_pwd, _m_ident, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::sdc::SessionIPrx& _result;
        const ::sdc::User& _m_participant;
        const ::std::string& _m_pwd;
        const ::Ice::Identity& _m_ident;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__AuthenticationI__login_name, ::Ice::Normal, __context);
    ::sdc::SessionIPrx __result;
    try
    {
        _DirectI __direct(__result, participant, pwd, ident, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::AuthenticationException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::std::string
IceDelegateD::sdc::AuthenticationI::echo(const ::std::string& message, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::std::string& message, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_message(message)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::AuthenticationI* servant = dynamic_cast< ::sdc::AuthenticationI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->echo(_m_message, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::std::string& _result;
        const ::std::string& _m_message;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__AuthenticationI__echo_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, message, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::SDCException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::sdc::ChatClientCallbackI::initChat(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_users(users),
            _m_chatID(chatID),
            _m_key(key)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::ChatClientCallbackI* servant = dynamic_cast< ::sdc::ChatClientCallbackI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->initChat(_m_users, _m_chatID, _m_key, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::StringSeq& _m_users;
        const ::std::string& _m_chatID;
        const ::sdc::ByteSeq& _m_key;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__ChatClientCallbackI__initChat_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(users, chatID, key, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::ChatException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::ChatClientCallbackI::addChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_participant(participant),
            _m_chatID(chatID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::ChatClientCallbackI* servant = dynamic_cast< ::sdc::ChatClientCallbackI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->addChatParticipant(_m_participant, _m_chatID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::User& _m_participant;
        const ::std::string& _m_chatID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__ChatClientCallbackI__addChatParticipant_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(participant, chatID, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::ParticipationException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::ChatClientCallbackI::removeChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_participant(participant),
            _m_chatID(chatID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::ChatClientCallbackI* servant = dynamic_cast< ::sdc::ChatClientCallbackI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->removeChatParticipant(_m_participant, _m_chatID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::User& _m_participant;
        const ::std::string& _m_chatID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__ChatClientCallbackI__removeChatParticipant_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(participant, chatID, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::ParticipationException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::ChatClientCallbackI::appendMessageToChat(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_message(message),
            _m_chatID(chatID),
            _m_participant(participant)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::ChatClientCallbackI* servant = dynamic_cast< ::sdc::ChatClientCallbackI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->appendMessageToChat(_m_message, _m_chatID, _m_participant, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::ByteSeq& _m_message;
        const ::std::string& _m_chatID;
        const ::sdc::User& _m_participant;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__ChatClientCallbackI__appendMessageToChat_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(message, chatID, participant, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::MessageCallbackException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::std::string
IceDelegateD::sdc::ChatClientCallbackI::echo(const ::std::string& message, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::std::string& message, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_message(message)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::ChatClientCallbackI* servant = dynamic_cast< ::sdc::ChatClientCallbackI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->echo(_m_message, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::std::string& _result;
        const ::std::string& _m_message;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__ChatClientCallbackI__echo_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, message, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::SDCException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::sdc::User
IceDelegateD::sdc::InterServerI::retrieveUser(const ::std::string& userID, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::sdc::User& __result, const ::std::string& userID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_userID(userID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::InterServerI* servant = dynamic_cast< ::sdc::InterServerI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->retrieveUser(_m_userID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::sdc::User& _result;
        const ::std::string& _m_userID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__InterServerI__retrieveUser_name, ::Ice::Normal, __context);
    ::sdc::User __result;
    try
    {
        _DirectI __direct(__result, userID, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::InterServerException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::sdc::InterServerI::invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_participant(participant),
            _m_chatID(chatID),
            _m_key(key)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::InterServerI* servant = dynamic_cast< ::sdc::InterServerI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->invite(_m_participant, _m_chatID, _m_key, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::User& _m_participant;
        const ::std::string& _m_chatID;
        const ::sdc::ByteSeq& _m_key;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__InterServerI__invite_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(participant, chatID, key, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::InterServerException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::InterServerI::sendMessage(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_sender(sender),
            _m_message(message),
            _m_chatID(chatID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::InterServerI* servant = dynamic_cast< ::sdc::InterServerI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->sendMessage(_m_sender, _m_message, _m_chatID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::User& _m_sender;
        const ::sdc::ByteSeq& _m_message;
        const ::std::string& _m_chatID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__InterServerI__sendMessage_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(sender, message, chatID, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::InterServerException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::InterServerI::leaveChat(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_participant(participant),
            _m_chatID(chatID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::InterServerI* servant = dynamic_cast< ::sdc::InterServerI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->leaveChat(_m_participant, _m_chatID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::User& _m_participant;
        const ::std::string& _m_chatID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__InterServerI__leaveChat_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(participant, chatID, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::InterServerException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::InterServerI::clientInitChat(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_client(client),
            _m_users(users),
            _m_chatID(chatID),
            _m_key(key)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::InterServerI* servant = dynamic_cast< ::sdc::InterServerI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->clientInitChat(_m_client, _m_users, _m_chatID, _m_key, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::User& _m_client;
        const ::sdc::StringSeq& _m_users;
        const ::std::string& _m_chatID;
        const ::sdc::ByteSeq& _m_key;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__InterServerI__clientInitChat_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(client, users, chatID, key, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::ChatException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::InterServerI::clientAddChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_client(client),
            _m_participant(participant),
            _m_chatID(chatID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::InterServerI* servant = dynamic_cast< ::sdc::InterServerI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->clientAddChatParticipant(_m_client, _m_participant, _m_chatID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::User& _m_client;
        const ::sdc::User& _m_participant;
        const ::std::string& _m_chatID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__InterServerI__clientAddChatParticipant_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(client, participant, chatID, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::ParticipationException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::InterServerI::clientRemoveChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_client(client),
            _m_participant(participant),
            _m_chatID(chatID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::InterServerI* servant = dynamic_cast< ::sdc::InterServerI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->clientRemoveChatParticipant(_m_client, _m_participant, _m_chatID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::User& _m_client;
        const ::sdc::User& _m_participant;
        const ::std::string& _m_chatID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__InterServerI__clientRemoveChatParticipant_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(client, participant, chatID, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::ParticipationException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::sdc::InterServerI::clientAppendMessageToChat(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_client(client),
            _m_message(message),
            _m_chatID(chatID),
            _m_participant(participant)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::sdc::InterServerI* servant = dynamic_cast< ::sdc::InterServerI*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->clientAppendMessageToChat(_m_client, _m_message, _m_chatID, _m_participant, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::sdc::User& _m_client;
        const ::sdc::ByteSeq& _m_message;
        const ::std::string& _m_chatID;
        const ::sdc::User& _m_participant;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __sdc__InterServerI__clientAppendMessageToChat_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(client, message, chatID, participant, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::sdc::MessageCallbackException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::ObjectPtr
sdc::SessionI::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __sdc__SessionI_ids[2] =
{
    "::Ice::Object",
    "::sdc::SessionI"
};

bool
sdc::SessionI::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__sdc__SessionI_ids, __sdc__SessionI_ids + 2, _s);
}

::std::vector< ::std::string>
sdc::SessionI::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__sdc__SessionI_ids[0], &__sdc__SessionI_ids[2]);
}

const ::std::string&
sdc::SessionI::ice_id(const ::Ice::Current&) const
{
    return __sdc__SessionI_ids[1];
}

const ::std::string&
sdc::SessionI::ice_staticId()
{
    return __sdc__SessionI_ids[1];
}

::Ice::DispatchStatus
sdc::SessionI::___logout(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        logout(__current);
    }
    catch(const ::sdc::UserHandlingException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::SessionI::___retrieveUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string userID;
    __is->read(userID);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::sdc::User __ret = retrieveUser(userID, __current);
        __ret.__write(__os);
    }
    catch(const ::sdc::InterServerException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    catch(const ::sdc::UserHandlingException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::SessionI::___initChat(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::std::string __ret = initChat(__current);
        __os->write(__ret);
    }
    catch(const ::sdc::SessionException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::SessionI::___leaveChat(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string chatID;
    __is->read(chatID);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        leaveChat(chatID, __current);
    }
    catch(const ::sdc::InterServerException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    catch(const ::sdc::SessionException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::SessionI::___invite(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User participant;
    ::std::string chatID;
    ::sdc::ByteSeq sessionKey;
    participant.__read(__is);
    __is->read(chatID);
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ___sessionKey;
    __is->read(___sessionKey);
    ::std::vector< ::Ice::Byte>(___sessionKey.first, ___sessionKey.second).swap(sessionKey);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        invite(participant, chatID, sessionKey, __current);
    }
    catch(const ::sdc::InterServerException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    catch(const ::sdc::UserHandlingException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::SessionI::___sendMessage(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::ByteSeq message;
    ::std::string chatID;
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ___message;
    __is->read(___message);
    ::std::vector< ::Ice::Byte>(___message.first, ___message.second).swap(message);
    __is->read(chatID);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        sendMessage(message, chatID, __current);
    }
    catch(const ::sdc::InterServerException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    catch(const ::sdc::MessageException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::SessionI::___deleteUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User participant;
    participant.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        deleteUser(participant, __current);
    }
    catch(const ::sdc::UserHandlingException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::SessionI::___saveLog(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string chatID;
    ::Ice::Long timestamp;
    ::sdc::SecureContainer log;
    __is->read(chatID);
    __is->read(timestamp);
    log.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        saveLog(chatID, timestamp, log, __current);
    }
    catch(const ::sdc::LogException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::SessionI::___retrieveLoglist(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::sdc::Loglist __ret = retrieveLoglist(__current);
        if(__ret.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::sdc::__writeLoglist(__os, &__ret[0], &__ret[0] + __ret.size());
        }
    }
    catch(const ::sdc::LogException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::SessionI::___retrieveLog(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string chatID;
    ::Ice::Long timestamp;
    __is->read(chatID);
    __is->read(timestamp);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::sdc::SecureContainer __ret = retrieveLog(chatID, timestamp, __current);
        __ret.__write(__os);
    }
    catch(const ::sdc::LogException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::SessionI::___saveContactList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::SecureContainer contactList;
    contactList.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        saveContactList(contactList, __current);
    }
    catch(const ::sdc::ContactException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::SessionI::___retrieveContactList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::sdc::SecureContainer __ret = retrieveContactList(__current);
        __ret.__write(__os);
    }
    catch(const ::sdc::ContactException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

static ::std::string __sdc__SessionI_all[] =
{
    "deleteUser",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "initChat",
    "invite",
    "leaveChat",
    "logout",
    "retrieveContactList",
    "retrieveLog",
    "retrieveLoglist",
    "retrieveUser",
    "saveContactList",
    "saveLog",
    "sendMessage"
};

::Ice::DispatchStatus
sdc::SessionI::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__sdc__SessionI_all, __sdc__SessionI_all + 16, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __sdc__SessionI_all)
    {
        case 0:
        {
            return ___deleteUser(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
        case 5:
        {
            return ___initChat(in, current);
        }
        case 6:
        {
            return ___invite(in, current);
        }
        case 7:
        {
            return ___leaveChat(in, current);
        }
        case 8:
        {
            return ___logout(in, current);
        }
        case 9:
        {
            return ___retrieveContactList(in, current);
        }
        case 10:
        {
            return ___retrieveLog(in, current);
        }
        case 11:
        {
            return ___retrieveLoglist(in, current);
        }
        case 12:
        {
            return ___retrieveUser(in, current);
        }
        case 13:
        {
            return ___saveContactList(in, current);
        }
        case 14:
        {
            return ___saveLog(in, current);
        }
        case 15:
        {
            return ___sendMessage(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
sdc::SessionI::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
sdc::SessionI::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::SessionI::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->writeTypeId(ice_staticId());
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__outS);
#else
    ::Ice::Object::__write(__outS);
#endif
}

void
sdc::SessionI::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        __inS->readTypeId();
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__inS, true);
#else
    ::Ice::Object::__read(__inS, true);
#endif
}
#endif

void 
sdc::__patch__SessionIPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::sdc::SessionIPtr* p = static_cast< ::sdc::SessionIPtr*>(__addr);
    assert(p);
    *p = ::sdc::SessionIPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::sdc::SessionI::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
sdc::AuthenticationI::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __sdc__AuthenticationI_ids[2] =
{
    "::Ice::Object",
    "::sdc::AuthenticationI"
};

bool
sdc::AuthenticationI::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__sdc__AuthenticationI_ids, __sdc__AuthenticationI_ids + 2, _s);
}

::std::vector< ::std::string>
sdc::AuthenticationI::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__sdc__AuthenticationI_ids[0], &__sdc__AuthenticationI_ids[2]);
}

const ::std::string&
sdc::AuthenticationI::ice_id(const ::Ice::Current&) const
{
    return __sdc__AuthenticationI_ids[1];
}

const ::std::string&
sdc::AuthenticationI::ice_staticId()
{
    return __sdc__AuthenticationI_ids[1];
}

::Ice::DispatchStatus
sdc::AuthenticationI::___registerUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User participant;
    ::std::string pwd;
    participant.__read(__is);
    __is->read(pwd);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        registerUser(participant, pwd, __current);
    }
    catch(const ::sdc::AuthenticationException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::AuthenticationI::___login(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User participant;
    ::std::string pwd;
    ::Ice::Identity ident;
    participant.__read(__is);
    __is->read(pwd);
    ident.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::sdc::SessionIPrx __ret = login(participant, pwd, ident, __current);
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(__ret.get())));
    }
    catch(const ::sdc::AuthenticationException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::AuthenticationI::___echo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string message;
    __is->read(message);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::std::string __ret = echo(message, __current);
        __os->write(__ret);
    }
    catch(const ::sdc::SDCException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

static ::std::string __sdc__AuthenticationI_all[] =
{
    "echo",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "login",
    "registerUser"
};

::Ice::DispatchStatus
sdc::AuthenticationI::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__sdc__AuthenticationI_all, __sdc__AuthenticationI_all + 7, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __sdc__AuthenticationI_all)
    {
        case 0:
        {
            return ___echo(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
        case 5:
        {
            return ___login(in, current);
        }
        case 6:
        {
            return ___registerUser(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
sdc::AuthenticationI::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
sdc::AuthenticationI::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::AuthenticationI::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->writeTypeId(ice_staticId());
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__outS);
#else
    ::Ice::Object::__write(__outS);
#endif
}

void
sdc::AuthenticationI::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        __inS->readTypeId();
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__inS, true);
#else
    ::Ice::Object::__read(__inS, true);
#endif
}
#endif

void 
sdc::__patch__AuthenticationIPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::sdc::AuthenticationIPtr* p = static_cast< ::sdc::AuthenticationIPtr*>(__addr);
    assert(p);
    *p = ::sdc::AuthenticationIPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::sdc::AuthenticationI::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
sdc::ChatClientCallbackI::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __sdc__ChatClientCallbackI_ids[2] =
{
    "::Ice::Object",
    "::sdc::ChatClientCallbackI"
};

bool
sdc::ChatClientCallbackI::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__sdc__ChatClientCallbackI_ids, __sdc__ChatClientCallbackI_ids + 2, _s);
}

::std::vector< ::std::string>
sdc::ChatClientCallbackI::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__sdc__ChatClientCallbackI_ids[0], &__sdc__ChatClientCallbackI_ids[2]);
}

const ::std::string&
sdc::ChatClientCallbackI::ice_id(const ::Ice::Current&) const
{
    return __sdc__ChatClientCallbackI_ids[1];
}

const ::std::string&
sdc::ChatClientCallbackI::ice_staticId()
{
    return __sdc__ChatClientCallbackI_ids[1];
}

::Ice::DispatchStatus
sdc::ChatClientCallbackI::___initChat(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::StringSeq users;
    ::std::string chatID;
    ::sdc::ByteSeq key;
    __is->read(users);
    __is->read(chatID);
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ___key;
    __is->read(___key);
    ::std::vector< ::Ice::Byte>(___key.first, ___key.second).swap(key);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        initChat(users, chatID, key, __current);
    }
    catch(const ::sdc::ChatException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::ChatClientCallbackI::___addChatParticipant(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User participant;
    ::std::string chatID;
    participant.__read(__is);
    __is->read(chatID);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        addChatParticipant(participant, chatID, __current);
    }
    catch(const ::sdc::ParticipationException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::ChatClientCallbackI::___removeChatParticipant(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User participant;
    ::std::string chatID;
    participant.__read(__is);
    __is->read(chatID);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        removeChatParticipant(participant, chatID, __current);
    }
    catch(const ::sdc::ParticipationException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::ChatClientCallbackI::___appendMessageToChat(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::ByteSeq message;
    ::std::string chatID;
    ::sdc::User participant;
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ___message;
    __is->read(___message);
    ::std::vector< ::Ice::Byte>(___message.first, ___message.second).swap(message);
    __is->read(chatID);
    participant.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        appendMessageToChat(message, chatID, participant, __current);
    }
    catch(const ::sdc::MessageCallbackException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::ChatClientCallbackI::___echo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string message;
    __is->read(message);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::std::string __ret = echo(message, __current);
        __os->write(__ret);
    }
    catch(const ::sdc::SDCException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

static ::std::string __sdc__ChatClientCallbackI_all[] =
{
    "addChatParticipant",
    "appendMessageToChat",
    "echo",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "initChat",
    "removeChatParticipant"
};

::Ice::DispatchStatus
sdc::ChatClientCallbackI::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__sdc__ChatClientCallbackI_all, __sdc__ChatClientCallbackI_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __sdc__ChatClientCallbackI_all)
    {
        case 0:
        {
            return ___addChatParticipant(in, current);
        }
        case 1:
        {
            return ___appendMessageToChat(in, current);
        }
        case 2:
        {
            return ___echo(in, current);
        }
        case 3:
        {
            return ___ice_id(in, current);
        }
        case 4:
        {
            return ___ice_ids(in, current);
        }
        case 5:
        {
            return ___ice_isA(in, current);
        }
        case 6:
        {
            return ___ice_ping(in, current);
        }
        case 7:
        {
            return ___initChat(in, current);
        }
        case 8:
        {
            return ___removeChatParticipant(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
sdc::ChatClientCallbackI::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
sdc::ChatClientCallbackI::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::ChatClientCallbackI::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->writeTypeId(ice_staticId());
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__outS);
#else
    ::Ice::Object::__write(__outS);
#endif
}

void
sdc::ChatClientCallbackI::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        __inS->readTypeId();
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__inS, true);
#else
    ::Ice::Object::__read(__inS, true);
#endif
}
#endif

void 
sdc::__patch__ChatClientCallbackIPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::sdc::ChatClientCallbackIPtr* p = static_cast< ::sdc::ChatClientCallbackIPtr*>(__addr);
    assert(p);
    *p = ::sdc::ChatClientCallbackIPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::sdc::ChatClientCallbackI::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
sdc::InterServerI::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __sdc__InterServerI_ids[2] =
{
    "::Ice::Object",
    "::sdc::InterServerI"
};

bool
sdc::InterServerI::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__sdc__InterServerI_ids, __sdc__InterServerI_ids + 2, _s);
}

::std::vector< ::std::string>
sdc::InterServerI::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__sdc__InterServerI_ids[0], &__sdc__InterServerI_ids[2]);
}

const ::std::string&
sdc::InterServerI::ice_id(const ::Ice::Current&) const
{
    return __sdc__InterServerI_ids[1];
}

const ::std::string&
sdc::InterServerI::ice_staticId()
{
    return __sdc__InterServerI_ids[1];
}

::Ice::DispatchStatus
sdc::InterServerI::___retrieveUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string userID;
    __is->read(userID);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::sdc::User __ret = retrieveUser(userID, __current);
        __ret.__write(__os);
    }
    catch(const ::sdc::InterServerException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::InterServerI::___invite(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User participant;
    ::std::string chatID;
    ::sdc::ByteSeq key;
    participant.__read(__is);
    __is->read(chatID);
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ___key;
    __is->read(___key);
    ::std::vector< ::Ice::Byte>(___key.first, ___key.second).swap(key);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        invite(participant, chatID, key, __current);
    }
    catch(const ::sdc::InterServerException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::InterServerI::___sendMessage(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User sender;
    ::sdc::ByteSeq message;
    ::std::string chatID;
    sender.__read(__is);
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ___message;
    __is->read(___message);
    ::std::vector< ::Ice::Byte>(___message.first, ___message.second).swap(message);
    __is->read(chatID);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        sendMessage(sender, message, chatID, __current);
    }
    catch(const ::sdc::InterServerException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::InterServerI::___leaveChat(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User participant;
    ::std::string chatID;
    participant.__read(__is);
    __is->read(chatID);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        leaveChat(participant, chatID, __current);
    }
    catch(const ::sdc::InterServerException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::InterServerI::___clientInitChat(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User client;
    ::sdc::StringSeq users;
    ::std::string chatID;
    ::sdc::ByteSeq key;
    client.__read(__is);
    __is->read(users);
    __is->read(chatID);
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ___key;
    __is->read(___key);
    ::std::vector< ::Ice::Byte>(___key.first, ___key.second).swap(key);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        clientInitChat(client, users, chatID, key, __current);
    }
    catch(const ::sdc::ChatException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::InterServerI::___clientAddChatParticipant(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User client;
    ::sdc::User participant;
    ::std::string chatID;
    client.__read(__is);
    participant.__read(__is);
    __is->read(chatID);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        clientAddChatParticipant(client, participant, chatID, __current);
    }
    catch(const ::sdc::ParticipationException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::InterServerI::___clientRemoveChatParticipant(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User client;
    ::sdc::User participant;
    ::std::string chatID;
    client.__read(__is);
    participant.__read(__is);
    __is->read(chatID);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        clientRemoveChatParticipant(client, participant, chatID, __current);
    }
    catch(const ::sdc::ParticipationException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
sdc::InterServerI::___clientAppendMessageToChat(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::sdc::User client;
    ::sdc::ByteSeq message;
    ::std::string chatID;
    ::sdc::User participant;
    client.__read(__is);
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ___message;
    __is->read(___message);
    ::std::vector< ::Ice::Byte>(___message.first, ___message.second).swap(message);
    __is->read(chatID);
    participant.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        clientAppendMessageToChat(client, message, chatID, participant, __current);
    }
    catch(const ::sdc::MessageCallbackException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

static ::std::string __sdc__InterServerI_all[] =
{
    "clientAddChatParticipant",
    "clientAppendMessageToChat",
    "clientInitChat",
    "clientRemoveChatParticipant",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "invite",
    "leaveChat",
    "retrieveUser",
    "sendMessage"
};

::Ice::DispatchStatus
sdc::InterServerI::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__sdc__InterServerI_all, __sdc__InterServerI_all + 12, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __sdc__InterServerI_all)
    {
        case 0:
        {
            return ___clientAddChatParticipant(in, current);
        }
        case 1:
        {
            return ___clientAppendMessageToChat(in, current);
        }
        case 2:
        {
            return ___clientInitChat(in, current);
        }
        case 3:
        {
            return ___clientRemoveChatParticipant(in, current);
        }
        case 4:
        {
            return ___ice_id(in, current);
        }
        case 5:
        {
            return ___ice_ids(in, current);
        }
        case 6:
        {
            return ___ice_isA(in, current);
        }
        case 7:
        {
            return ___ice_ping(in, current);
        }
        case 8:
        {
            return ___invite(in, current);
        }
        case 9:
        {
            return ___leaveChat(in, current);
        }
        case 10:
        {
            return ___retrieveUser(in, current);
        }
        case 11:
        {
            return ___sendMessage(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
sdc::InterServerI::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
sdc::InterServerI::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
sdc::InterServerI::__write(const ::Ice::OutputStreamPtr& __outS) const
{
    __outS->writeTypeId(ice_staticId());
    __outS->startSlice();
    __outS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__outS);
#else
    ::Ice::Object::__write(__outS);
#endif
}

void
sdc::InterServerI::__read(const ::Ice::InputStreamPtr& __inS, bool __rid)
{
    if(__rid)
    {
        __inS->readTypeId();
    }
    __inS->startSlice();
    __inS->endSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__inS, true);
#else
    ::Ice::Object::__read(__inS, true);
#endif
}
#endif

void 
sdc::__patch__InterServerIPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::sdc::InterServerIPtr* p = static_cast< ::sdc::InterServerIPtr*>(__addr);
    assert(p);
    *p = ::sdc::InterServerIPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::sdc::InterServerI::ice_staticId(), v->ice_id());
    }
}
