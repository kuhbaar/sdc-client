// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `SecureDistributedChat.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef ___home_zacky_Projects_SEPM_Einzel_task2_SecureDistributedChat_h__
#define ___home_zacky_Projects_SEPM_Einzel_task2_SecureDistributedChat_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Stream.h>
#include <Ice/Identity.h>
#include <Ice/UndefSysMacros.h>
#include <cstddef>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace sdc
{

class ChatClientCallbackI;

class SessionI;

class AuthenticationI;

class InterServerI;

}

}

namespace sdc
{

class ChatClientCallbackI;
bool operator==(const ChatClientCallbackI&, const ChatClientCallbackI&);
bool operator<(const ChatClientCallbackI&, const ChatClientCallbackI&);

class SessionI;
bool operator==(const SessionI&, const SessionI&);
bool operator<(const SessionI&, const SessionI&);

class AuthenticationI;
bool operator==(const AuthenticationI&, const AuthenticationI&);
bool operator<(const AuthenticationI&, const AuthenticationI&);

class InterServerI;
bool operator==(const InterServerI&, const InterServerI&);
bool operator<(const InterServerI&, const InterServerI&);

}

namespace IceInternal
{

::Ice::Object* upCast(::sdc::ChatClientCallbackI*);
::IceProxy::Ice::Object* upCast(::IceProxy::sdc::ChatClientCallbackI*);

::Ice::Object* upCast(::sdc::SessionI*);
::IceProxy::Ice::Object* upCast(::IceProxy::sdc::SessionI*);

::Ice::Object* upCast(::sdc::AuthenticationI*);
::IceProxy::Ice::Object* upCast(::IceProxy::sdc::AuthenticationI*);

::Ice::Object* upCast(::sdc::InterServerI*);
::IceProxy::Ice::Object* upCast(::IceProxy::sdc::InterServerI*);

}

namespace sdc
{

typedef ::IceInternal::Handle< ::sdc::ChatClientCallbackI> ChatClientCallbackIPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::sdc::ChatClientCallbackI> ChatClientCallbackIPrx;

void __read(::IceInternal::BasicStream*, ChatClientCallbackIPrx&);
void __patch__ChatClientCallbackIPtr(void*, ::Ice::ObjectPtr&);

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
ICE_DEPRECATED_API void ice_writeChatClientCallbackIPrx(const ::Ice::OutputStreamPtr&, const ChatClientCallbackIPrx&);
ICE_DEPRECATED_API void ice_readChatClientCallbackIPrx(const ::Ice::InputStreamPtr&, ChatClientCallbackIPrx&);
ICE_DEPRECATED_API void ice_writeChatClientCallbackI(const ::Ice::OutputStreamPtr&, const ChatClientCallbackIPtr&);
ICE_DEPRECATED_API void ice_readChatClientCallbackI(const ::Ice::InputStreamPtr&, ChatClientCallbackIPtr&);
#endif

typedef ::IceInternal::Handle< ::sdc::SessionI> SessionIPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::sdc::SessionI> SessionIPrx;

void __read(::IceInternal::BasicStream*, SessionIPrx&);
void __patch__SessionIPtr(void*, ::Ice::ObjectPtr&);

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
ICE_DEPRECATED_API void ice_writeSessionIPrx(const ::Ice::OutputStreamPtr&, const SessionIPrx&);
ICE_DEPRECATED_API void ice_readSessionIPrx(const ::Ice::InputStreamPtr&, SessionIPrx&);
ICE_DEPRECATED_API void ice_writeSessionI(const ::Ice::OutputStreamPtr&, const SessionIPtr&);
ICE_DEPRECATED_API void ice_readSessionI(const ::Ice::InputStreamPtr&, SessionIPtr&);
#endif

typedef ::IceInternal::Handle< ::sdc::AuthenticationI> AuthenticationIPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::sdc::AuthenticationI> AuthenticationIPrx;

void __read(::IceInternal::BasicStream*, AuthenticationIPrx&);
void __patch__AuthenticationIPtr(void*, ::Ice::ObjectPtr&);

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
ICE_DEPRECATED_API void ice_writeAuthenticationIPrx(const ::Ice::OutputStreamPtr&, const AuthenticationIPrx&);
ICE_DEPRECATED_API void ice_readAuthenticationIPrx(const ::Ice::InputStreamPtr&, AuthenticationIPrx&);
ICE_DEPRECATED_API void ice_writeAuthenticationI(const ::Ice::OutputStreamPtr&, const AuthenticationIPtr&);
ICE_DEPRECATED_API void ice_readAuthenticationI(const ::Ice::InputStreamPtr&, AuthenticationIPtr&);
#endif

typedef ::IceInternal::Handle< ::sdc::InterServerI> InterServerIPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::sdc::InterServerI> InterServerIPrx;

void __read(::IceInternal::BasicStream*, InterServerIPrx&);
void __patch__InterServerIPtr(void*, ::Ice::ObjectPtr&);

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
ICE_DEPRECATED_API void ice_writeInterServerIPrx(const ::Ice::OutputStreamPtr&, const InterServerIPrx&);
ICE_DEPRECATED_API void ice_readInterServerIPrx(const ::Ice::InputStreamPtr&, InterServerIPrx&);
ICE_DEPRECATED_API void ice_writeInterServerI(const ::Ice::OutputStreamPtr&, const InterServerIPtr&);
ICE_DEPRECATED_API void ice_readInterServerI(const ::Ice::InputStreamPtr&, InterServerIPtr&);
#endif

}

namespace sdc
{

const ::Ice::Int port = 1337;

typedef ::std::vector< ::Ice::Byte> ByteSeq;

typedef ::std::vector< ::std::string> StringSeq;

class SDCException : public ::Ice::UserException
{
public:

    SDCException() {}
    explicit SDCException(const ::std::string&);
    virtual ~SDCException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    ::std::string what;

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

static SDCException __SDCException_init;

class AuthenticationException : public ::sdc::SDCException
{
public:

    AuthenticationException() {}
    explicit AuthenticationException(const ::std::string&);
    virtual ~AuthenticationException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class SessionException : public ::sdc::SDCException
{
public:

    SessionException() {}
    explicit SessionException(const ::std::string&);
    virtual ~SessionException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class UserHandlingException : public ::sdc::SessionException
{
public:

    UserHandlingException() {}
    explicit UserHandlingException(const ::std::string&);
    virtual ~UserHandlingException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class MessageException : public ::sdc::SessionException
{
public:

    MessageException() {}
    explicit MessageException(const ::std::string&);
    virtual ~MessageException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class LogException : public ::sdc::SessionException
{
public:

    LogException() {}
    explicit LogException(const ::std::string&);
    virtual ~LogException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class ContactException : public ::sdc::SessionException
{
public:

    ContactException() {}
    explicit ContactException(const ::std::string&);
    virtual ~ContactException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class ChatClientCallbackException : public ::sdc::SDCException
{
public:

    ChatClientCallbackException() {}
    explicit ChatClientCallbackException(const ::std::string&);
    virtual ~ChatClientCallbackException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class ChatException : public ::sdc::ChatClientCallbackException
{
public:

    ChatException() {}
    explicit ChatException(const ::std::string&);
    virtual ~ChatException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class ParticipationException : public ::sdc::ChatClientCallbackException
{
public:

    ParticipationException() {}
    explicit ParticipationException(const ::std::string&);
    virtual ~ParticipationException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class MessageCallbackException : public ::sdc::ChatClientCallbackException
{
public:

    MessageCallbackException() {}
    explicit MessageCallbackException(const ::std::string&);
    virtual ~MessageCallbackException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class InterServerException : public ::sdc::SDCException
{
public:

    InterServerException() {}
    explicit InterServerException(const ::std::string&);
    virtual ~InterServerException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

struct User
{
    ::std::string ID;
    ::sdc::ByteSeq publicKey;

    bool operator==(const User& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(ID != __rhs.ID)
        {
            return false;
        }
        if(publicKey != __rhs.publicKey)
        {
            return false;
        }
        return true;
    }

    bool operator<(const User& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(ID < __rhs.ID)
        {
            return true;
        }
        else if(__rhs.ID < ID)
        {
            return false;
        }
        if(publicKey < __rhs.publicKey)
        {
            return true;
        }
        else if(__rhs.publicKey < publicKey)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const User& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const User& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const User& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const User& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    void ice_write(const ::Ice::OutputStreamPtr&) const;
    void ice_read(const ::Ice::InputStreamPtr&);
#endif
};

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void ice_writeUser(const ::Ice::OutputStreamPtr&, const User&);
void ice_readUser(const ::Ice::InputStreamPtr&, User&);
#endif

typedef ::std::vector< ::sdc::User> ContactList;
void __writeContactList(::IceInternal::BasicStream*, const ::sdc::User*, const ::sdc::User*);
void __readContactList(::IceInternal::BasicStream*, ContactList&);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
ICE_DEPRECATED_API void ice_writeContactList(const ::Ice::OutputStreamPtr&, const ContactList&);
ICE_DEPRECATED_API void ice_readContactList(const ::Ice::InputStreamPtr&, ContactList&);
#endif

struct LogMessage
{
    ::std::string senderID;
    ::Ice::Long timestamp;
    ::std::string message;

    bool operator==(const LogMessage& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(senderID != __rhs.senderID)
        {
            return false;
        }
        if(timestamp != __rhs.timestamp)
        {
            return false;
        }
        if(message != __rhs.message)
        {
            return false;
        }
        return true;
    }

    bool operator<(const LogMessage& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(senderID < __rhs.senderID)
        {
            return true;
        }
        else if(__rhs.senderID < senderID)
        {
            return false;
        }
        if(timestamp < __rhs.timestamp)
        {
            return true;
        }
        else if(__rhs.timestamp < timestamp)
        {
            return false;
        }
        if(message < __rhs.message)
        {
            return true;
        }
        else if(__rhs.message < message)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const LogMessage& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const LogMessage& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const LogMessage& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const LogMessage& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    void ice_write(const ::Ice::OutputStreamPtr&) const;
    void ice_read(const ::Ice::InputStreamPtr&);
#endif
};

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void ice_writeLogMessage(const ::Ice::OutputStreamPtr&, const LogMessage&);
void ice_readLogMessage(const ::Ice::InputStreamPtr&, LogMessage&);
#endif

typedef ::std::vector< ::sdc::LogMessage> Chatlog;
void __writeChatlog(::IceInternal::BasicStream*, const ::sdc::LogMessage*, const ::sdc::LogMessage*);
void __readChatlog(::IceInternal::BasicStream*, Chatlog&);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
ICE_DEPRECATED_API void ice_writeChatlog(const ::Ice::OutputStreamPtr&, const Chatlog&);
ICE_DEPRECATED_API void ice_readChatlog(const ::Ice::InputStreamPtr&, Chatlog&);
#endif

struct ChatlogEntry
{
    ::std::string chatID;
    ::Ice::Long timestamp;

    bool operator==(const ChatlogEntry& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(chatID != __rhs.chatID)
        {
            return false;
        }
        if(timestamp != __rhs.timestamp)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ChatlogEntry& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(chatID < __rhs.chatID)
        {
            return true;
        }
        else if(__rhs.chatID < chatID)
        {
            return false;
        }
        if(timestamp < __rhs.timestamp)
        {
            return true;
        }
        else if(__rhs.timestamp < timestamp)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ChatlogEntry& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ChatlogEntry& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ChatlogEntry& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ChatlogEntry& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    void ice_write(const ::Ice::OutputStreamPtr&) const;
    void ice_read(const ::Ice::InputStreamPtr&);
#endif
};

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void ice_writeChatlogEntry(const ::Ice::OutputStreamPtr&, const ChatlogEntry&);
void ice_readChatlogEntry(const ::Ice::InputStreamPtr&, ChatlogEntry&);
#endif

typedef ::std::vector< ::sdc::ChatlogEntry> Loglist;
void __writeLoglist(::IceInternal::BasicStream*, const ::sdc::ChatlogEntry*, const ::sdc::ChatlogEntry*);
void __readLoglist(::IceInternal::BasicStream*, Loglist&);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
ICE_DEPRECATED_API void ice_writeLoglist(const ::Ice::OutputStreamPtr&, const Loglist&);
ICE_DEPRECATED_API void ice_readLoglist(const ::Ice::InputStreamPtr&, Loglist&);
#endif

struct SecureContainer
{
    ::sdc::ByteSeq data;
    ::sdc::ByteSeq signature;

    bool operator==(const SecureContainer& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(data != __rhs.data)
        {
            return false;
        }
        if(signature != __rhs.signature)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SecureContainer& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(data < __rhs.data)
        {
            return true;
        }
        else if(__rhs.data < data)
        {
            return false;
        }
        if(signature < __rhs.signature)
        {
            return true;
        }
        else if(__rhs.signature < signature)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SecureContainer& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const SecureContainer& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const SecureContainer& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const SecureContainer& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    void ice_write(const ::Ice::OutputStreamPtr&) const;
    void ice_read(const ::Ice::InputStreamPtr&);
#endif
};

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void ice_writeSecureContainer(const ::Ice::OutputStreamPtr&, const SecureContainer&);
void ice_readSecureContainer(const ::Ice::InputStreamPtr&, SecureContainer&);
#endif

}

namespace sdc
{

class Callback_SessionI_logout_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SessionI_logout_Base> Callback_SessionI_logoutPtr;

class Callback_SessionI_retrieveUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SessionI_retrieveUser_Base> Callback_SessionI_retrieveUserPtr;

class Callback_SessionI_initChat_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SessionI_initChat_Base> Callback_SessionI_initChatPtr;

class Callback_SessionI_leaveChat_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SessionI_leaveChat_Base> Callback_SessionI_leaveChatPtr;

class Callback_SessionI_invite_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SessionI_invite_Base> Callback_SessionI_invitePtr;

class Callback_SessionI_sendMessage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SessionI_sendMessage_Base> Callback_SessionI_sendMessagePtr;

class Callback_SessionI_deleteUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SessionI_deleteUser_Base> Callback_SessionI_deleteUserPtr;

class Callback_SessionI_saveLog_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SessionI_saveLog_Base> Callback_SessionI_saveLogPtr;

class Callback_SessionI_retrieveLoglist_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SessionI_retrieveLoglist_Base> Callback_SessionI_retrieveLoglistPtr;

class Callback_SessionI_retrieveLog_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SessionI_retrieveLog_Base> Callback_SessionI_retrieveLogPtr;

class Callback_SessionI_saveContactList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SessionI_saveContactList_Base> Callback_SessionI_saveContactListPtr;

class Callback_SessionI_retrieveContactList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SessionI_retrieveContactList_Base> Callback_SessionI_retrieveContactListPtr;

class Callback_AuthenticationI_registerUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_AuthenticationI_registerUser_Base> Callback_AuthenticationI_registerUserPtr;

class Callback_AuthenticationI_login_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_AuthenticationI_login_Base> Callback_AuthenticationI_loginPtr;

class Callback_AuthenticationI_echo_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_AuthenticationI_echo_Base> Callback_AuthenticationI_echoPtr;

class Callback_ChatClientCallbackI_initChat_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatClientCallbackI_initChat_Base> Callback_ChatClientCallbackI_initChatPtr;

class Callback_ChatClientCallbackI_addChatParticipant_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatClientCallbackI_addChatParticipant_Base> Callback_ChatClientCallbackI_addChatParticipantPtr;

class Callback_ChatClientCallbackI_removeChatParticipant_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatClientCallbackI_removeChatParticipant_Base> Callback_ChatClientCallbackI_removeChatParticipantPtr;

class Callback_ChatClientCallbackI_appendMessageToChat_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatClientCallbackI_appendMessageToChat_Base> Callback_ChatClientCallbackI_appendMessageToChatPtr;

class Callback_ChatClientCallbackI_echo_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatClientCallbackI_echo_Base> Callback_ChatClientCallbackI_echoPtr;

class Callback_InterServerI_retrieveUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InterServerI_retrieveUser_Base> Callback_InterServerI_retrieveUserPtr;

class Callback_InterServerI_invite_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InterServerI_invite_Base> Callback_InterServerI_invitePtr;

class Callback_InterServerI_sendMessage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InterServerI_sendMessage_Base> Callback_InterServerI_sendMessagePtr;

class Callback_InterServerI_leaveChat_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InterServerI_leaveChat_Base> Callback_InterServerI_leaveChatPtr;

class Callback_InterServerI_clientInitChat_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InterServerI_clientInitChat_Base> Callback_InterServerI_clientInitChatPtr;

class Callback_InterServerI_clientAddChatParticipant_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InterServerI_clientAddChatParticipant_Base> Callback_InterServerI_clientAddChatParticipantPtr;

class Callback_InterServerI_clientRemoveChatParticipant_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InterServerI_clientRemoveChatParticipant_Base> Callback_InterServerI_clientRemoveChatParticipantPtr;

class Callback_InterServerI_clientAppendMessageToChat_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InterServerI_clientAppendMessageToChat_Base> Callback_InterServerI_clientAppendMessageToChatPtr;

}

namespace IceProxy
{

namespace sdc
{

class SessionI : virtual public ::IceProxy::Ice::Object
{
public:

    void logout()
    {
        logout(0);
    }
    void logout(const ::Ice::Context& __ctx)
    {
        logout(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_logout()
    {
        return begin_logout(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::Ice::Context& __ctx)
    {
        return begin_logout(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logout(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logout(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::sdc::Callback_SessionI_logoutPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logout(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::Ice::Context& __ctx, const ::sdc::Callback_SessionI_logoutPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logout(&__ctx, __del, __cookie);
    }

    void end_logout(const ::Ice::AsyncResultPtr&);
    
private:

    void logout(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_logout(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::sdc::User retrieveUser(const ::std::string& userID)
    {
        return retrieveUser(userID, 0);
    }
    ::sdc::User retrieveUser(const ::std::string& userID, const ::Ice::Context& __ctx)
    {
        return retrieveUser(userID, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string& userID)
    {
        return begin_retrieveUser(userID, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string& userID, const ::Ice::Context& __ctx)
    {
        return begin_retrieveUser(userID, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string& userID, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveUser(userID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string& userID, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveUser(userID, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string& userID, const ::sdc::Callback_SessionI_retrieveUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveUser(userID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string& userID, const ::Ice::Context& __ctx, const ::sdc::Callback_SessionI_retrieveUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveUser(userID, &__ctx, __del, __cookie);
    }

    ::sdc::User end_retrieveUser(const ::Ice::AsyncResultPtr&);
    
private:

    ::sdc::User retrieveUser(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string initChat()
    {
        return initChat(0);
    }
    ::std::string initChat(const ::Ice::Context& __ctx)
    {
        return initChat(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_initChat()
    {
        return begin_initChat(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_initChat(const ::Ice::Context& __ctx)
    {
        return begin_initChat(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_initChat(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_initChat(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_initChat(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_initChat(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_initChat(const ::sdc::Callback_SessionI_initChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_initChat(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_initChat(const ::Ice::Context& __ctx, const ::sdc::Callback_SessionI_initChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_initChat(&__ctx, __del, __cookie);
    }

    ::std::string end_initChat(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string initChat(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_initChat(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void leaveChat(const ::std::string& chatID)
    {
        leaveChat(chatID, 0);
    }
    void leaveChat(const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        leaveChat(chatID, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_leaveChat(const ::std::string& chatID)
    {
        return begin_leaveChat(chatID, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_leaveChat(const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        return begin_leaveChat(chatID, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_leaveChat(const ::std::string& chatID, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_leaveChat(chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_leaveChat(const ::std::string& chatID, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_leaveChat(chatID, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_leaveChat(const ::std::string& chatID, const ::sdc::Callback_SessionI_leaveChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_leaveChat(chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_leaveChat(const ::std::string& chatID, const ::Ice::Context& __ctx, const ::sdc::Callback_SessionI_leaveChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_leaveChat(chatID, &__ctx, __del, __cookie);
    }

    void end_leaveChat(const ::Ice::AsyncResultPtr&);
    
private:

    void leaveChat(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_leaveChat(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey)
    {
        invite(participant, chatID, sessionKey, 0);
    }
    void invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey, const ::Ice::Context& __ctx)
    {
        invite(participant, chatID, sessionKey, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey)
    {
        return begin_invite(participant, chatID, sessionKey, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey, const ::Ice::Context& __ctx)
    {
        return begin_invite(participant, chatID, sessionKey, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invite(participant, chatID, sessionKey, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invite(participant, chatID, sessionKey, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey, const ::sdc::Callback_SessionI_invitePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invite(participant, chatID, sessionKey, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& sessionKey, const ::Ice::Context& __ctx, const ::sdc::Callback_SessionI_invitePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invite(participant, chatID, sessionKey, &__ctx, __del, __cookie);
    }

    void end_invite(const ::Ice::AsyncResultPtr&);
    
private:

    void invite(const ::sdc::User&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void sendMessage(const ::sdc::ByteSeq& message, const ::std::string& chatID)
    {
        sendMessage(message, chatID, 0);
    }
    void sendMessage(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        sendMessage(message, chatID, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::ByteSeq& message, const ::std::string& chatID)
    {
        return begin_sendMessage(message, chatID, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        return begin_sendMessage(message, chatID, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(message, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(message, chatID, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::Callback_SessionI_sendMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(message, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::sdc::Callback_SessionI_sendMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(message, chatID, &__ctx, __del, __cookie);
    }

    void end_sendMessage(const ::Ice::AsyncResultPtr&);
    
private:

    void sendMessage(const ::sdc::ByteSeq&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::ByteSeq&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void deleteUser(const ::sdc::User& participant)
    {
        deleteUser(participant, 0);
    }
    void deleteUser(const ::sdc::User& participant, const ::Ice::Context& __ctx)
    {
        deleteUser(participant, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_deleteUser(const ::sdc::User& participant)
    {
        return begin_deleteUser(participant, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deleteUser(const ::sdc::User& participant, const ::Ice::Context& __ctx)
    {
        return begin_deleteUser(participant, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deleteUser(const ::sdc::User& participant, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deleteUser(participant, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteUser(const ::sdc::User& participant, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deleteUser(participant, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteUser(const ::sdc::User& participant, const ::sdc::Callback_SessionI_deleteUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deleteUser(participant, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteUser(const ::sdc::User& participant, const ::Ice::Context& __ctx, const ::sdc::Callback_SessionI_deleteUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deleteUser(participant, &__ctx, __del, __cookie);
    }

    void end_deleteUser(const ::Ice::AsyncResultPtr&);
    
private:

    void deleteUser(const ::sdc::User&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_deleteUser(const ::sdc::User&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void saveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log)
    {
        saveLog(chatID, timestamp, log, 0);
    }
    void saveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log, const ::Ice::Context& __ctx)
    {
        saveLog(chatID, timestamp, log, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_saveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log)
    {
        return begin_saveLog(chatID, timestamp, log, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log, const ::Ice::Context& __ctx)
    {
        return begin_saveLog(chatID, timestamp, log, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveLog(chatID, timestamp, log, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveLog(chatID, timestamp, log, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log, const ::sdc::Callback_SessionI_saveLogPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveLog(chatID, timestamp, log, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::SecureContainer& log, const ::Ice::Context& __ctx, const ::sdc::Callback_SessionI_saveLogPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveLog(chatID, timestamp, log, &__ctx, __del, __cookie);
    }

    void end_saveLog(const ::Ice::AsyncResultPtr&);
    
private:

    void saveLog(const ::std::string&, ::Ice::Long, const ::sdc::SecureContainer&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_saveLog(const ::std::string&, ::Ice::Long, const ::sdc::SecureContainer&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::sdc::Loglist retrieveLoglist()
    {
        return retrieveLoglist(0);
    }
    ::sdc::Loglist retrieveLoglist(const ::Ice::Context& __ctx)
    {
        return retrieveLoglist(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_retrieveLoglist()
    {
        return begin_retrieveLoglist(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retrieveLoglist(const ::Ice::Context& __ctx)
    {
        return begin_retrieveLoglist(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retrieveLoglist(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveLoglist(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveLoglist(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveLoglist(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveLoglist(const ::sdc::Callback_SessionI_retrieveLoglistPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveLoglist(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveLoglist(const ::Ice::Context& __ctx, const ::sdc::Callback_SessionI_retrieveLoglistPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveLoglist(&__ctx, __del, __cookie);
    }

    ::sdc::Loglist end_retrieveLoglist(const ::Ice::AsyncResultPtr&);
    
private:

    ::sdc::Loglist retrieveLoglist(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_retrieveLoglist(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::sdc::SecureContainer retrieveLog(const ::std::string& chatID, ::Ice::Long timestamp)
    {
        return retrieveLog(chatID, timestamp, 0);
    }
    ::sdc::SecureContainer retrieveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::Ice::Context& __ctx)
    {
        return retrieveLog(chatID, timestamp, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_retrieveLog(const ::std::string& chatID, ::Ice::Long timestamp)
    {
        return begin_retrieveLog(chatID, timestamp, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retrieveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::Ice::Context& __ctx)
    {
        return begin_retrieveLog(chatID, timestamp, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retrieveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveLog(chatID, timestamp, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveLog(chatID, timestamp, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::sdc::Callback_SessionI_retrieveLogPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveLog(chatID, timestamp, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveLog(const ::std::string& chatID, ::Ice::Long timestamp, const ::Ice::Context& __ctx, const ::sdc::Callback_SessionI_retrieveLogPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveLog(chatID, timestamp, &__ctx, __del, __cookie);
    }

    ::sdc::SecureContainer end_retrieveLog(const ::Ice::AsyncResultPtr&);
    
private:

    ::sdc::SecureContainer retrieveLog(const ::std::string&, ::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_retrieveLog(const ::std::string&, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void saveContactList(const ::sdc::SecureContainer& contactList)
    {
        saveContactList(contactList, 0);
    }
    void saveContactList(const ::sdc::SecureContainer& contactList, const ::Ice::Context& __ctx)
    {
        saveContactList(contactList, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_saveContactList(const ::sdc::SecureContainer& contactList)
    {
        return begin_saveContactList(contactList, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveContactList(const ::sdc::SecureContainer& contactList, const ::Ice::Context& __ctx)
    {
        return begin_saveContactList(contactList, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_saveContactList(const ::sdc::SecureContainer& contactList, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveContactList(contactList, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveContactList(const ::sdc::SecureContainer& contactList, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveContactList(contactList, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveContactList(const ::sdc::SecureContainer& contactList, const ::sdc::Callback_SessionI_saveContactListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveContactList(contactList, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_saveContactList(const ::sdc::SecureContainer& contactList, const ::Ice::Context& __ctx, const ::sdc::Callback_SessionI_saveContactListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_saveContactList(contactList, &__ctx, __del, __cookie);
    }

    void end_saveContactList(const ::Ice::AsyncResultPtr&);
    
private:

    void saveContactList(const ::sdc::SecureContainer&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_saveContactList(const ::sdc::SecureContainer&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::sdc::SecureContainer retrieveContactList()
    {
        return retrieveContactList(0);
    }
    ::sdc::SecureContainer retrieveContactList(const ::Ice::Context& __ctx)
    {
        return retrieveContactList(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_retrieveContactList()
    {
        return begin_retrieveContactList(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retrieveContactList(const ::Ice::Context& __ctx)
    {
        return begin_retrieveContactList(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retrieveContactList(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveContactList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveContactList(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveContactList(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveContactList(const ::sdc::Callback_SessionI_retrieveContactListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveContactList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveContactList(const ::Ice::Context& __ctx, const ::sdc::Callback_SessionI_retrieveContactListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveContactList(&__ctx, __del, __cookie);
    }

    ::sdc::SecureContainer end_retrieveContactList(const ::Ice::AsyncResultPtr&);
    
private:

    ::sdc::SecureContainer retrieveContactList(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_retrieveContactList(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<SessionI> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<SessionI> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<SessionI*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<SessionI*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class AuthenticationI : virtual public ::IceProxy::Ice::Object
{
public:

    void registerUser(const ::sdc::User& participant, const ::std::string& pwd)
    {
        registerUser(participant, pwd, 0);
    }
    void registerUser(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Context& __ctx)
    {
        registerUser(participant, pwd, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::sdc::User& participant, const ::std::string& pwd)
    {
        return begin_registerUser(participant, pwd, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Context& __ctx)
    {
        return begin_registerUser(participant, pwd, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(participant, pwd, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(participant, pwd, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::sdc::User& participant, const ::std::string& pwd, const ::sdc::Callback_AuthenticationI_registerUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(participant, pwd, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Context& __ctx, const ::sdc::Callback_AuthenticationI_registerUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(participant, pwd, &__ctx, __del, __cookie);
    }

    void end_registerUser(const ::Ice::AsyncResultPtr&);
    
private:

    void registerUser(const ::sdc::User&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_registerUser(const ::sdc::User&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::sdc::SessionIPrx login(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident)
    {
        return login(participant, pwd, ident, 0);
    }
    ::sdc::SessionIPrx login(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident, const ::Ice::Context& __ctx)
    {
        return login(participant, pwd, ident, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_login(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident)
    {
        return begin_login(participant, pwd, ident, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_login(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident, const ::Ice::Context& __ctx)
    {
        return begin_login(participant, pwd, ident, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_login(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(participant, pwd, ident, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(participant, pwd, ident, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident, const ::sdc::Callback_AuthenticationI_loginPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(participant, pwd, ident, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login(const ::sdc::User& participant, const ::std::string& pwd, const ::Ice::Identity& ident, const ::Ice::Context& __ctx, const ::sdc::Callback_AuthenticationI_loginPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(participant, pwd, ident, &__ctx, __del, __cookie);
    }

    ::sdc::SessionIPrx end_login(const ::Ice::AsyncResultPtr&);
    
private:

    ::sdc::SessionIPrx login(const ::sdc::User&, const ::std::string&, const ::Ice::Identity&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_login(const ::sdc::User&, const ::std::string&, const ::Ice::Identity&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string echo(const ::std::string& message)
    {
        return echo(message, 0);
    }
    ::std::string echo(const ::std::string& message, const ::Ice::Context& __ctx)
    {
        return echo(message, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_echo(const ::std::string& message)
    {
        return begin_echo(message, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_echo(const ::std::string& message, const ::Ice::Context& __ctx)
    {
        return begin_echo(message, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_echo(const ::std::string& message, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_echo(message, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_echo(const ::std::string& message, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_echo(message, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_echo(const ::std::string& message, const ::sdc::Callback_AuthenticationI_echoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_echo(message, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_echo(const ::std::string& message, const ::Ice::Context& __ctx, const ::sdc::Callback_AuthenticationI_echoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_echo(message, &__ctx, __del, __cookie);
    }

    ::std::string end_echo(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string echo(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_echo(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<AuthenticationI> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<AuthenticationI*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<AuthenticationI*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ChatClientCallbackI : virtual public ::IceProxy::Ice::Object
{
public:

    void initChat(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key)
    {
        initChat(users, chatID, key, 0);
    }
    void initChat(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context& __ctx)
    {
        initChat(users, chatID, key, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_initChat(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key)
    {
        return begin_initChat(users, chatID, key, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_initChat(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context& __ctx)
    {
        return begin_initChat(users, chatID, key, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_initChat(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_initChat(users, chatID, key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_initChat(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_initChat(users, chatID, key, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_initChat(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::sdc::Callback_ChatClientCallbackI_initChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_initChat(users, chatID, key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_initChat(const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context& __ctx, const ::sdc::Callback_ChatClientCallbackI_initChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_initChat(users, chatID, key, &__ctx, __del, __cookie);
    }

    void end_initChat(const ::Ice::AsyncResultPtr&);
    
private:

    void initChat(const ::sdc::StringSeq&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_initChat(const ::sdc::StringSeq&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addChatParticipant(const ::sdc::User& participant, const ::std::string& chatID)
    {
        addChatParticipant(participant, chatID, 0);
    }
    void addChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        addChatParticipant(participant, chatID, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addChatParticipant(const ::sdc::User& participant, const ::std::string& chatID)
    {
        return begin_addChatParticipant(participant, chatID, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        return begin_addChatParticipant(participant, chatID, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChatParticipant(participant, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChatParticipant(participant, chatID, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::Callback_ChatClientCallbackI_addChatParticipantPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChatParticipant(participant, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::sdc::Callback_ChatClientCallbackI_addChatParticipantPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addChatParticipant(participant, chatID, &__ctx, __del, __cookie);
    }

    void end_addChatParticipant(const ::Ice::AsyncResultPtr&);
    
private:

    void addChatParticipant(const ::sdc::User&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addChatParticipant(const ::sdc::User&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeChatParticipant(const ::sdc::User& participant, const ::std::string& chatID)
    {
        removeChatParticipant(participant, chatID, 0);
    }
    void removeChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        removeChatParticipant(participant, chatID, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeChatParticipant(const ::sdc::User& participant, const ::std::string& chatID)
    {
        return begin_removeChatParticipant(participant, chatID, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        return begin_removeChatParticipant(participant, chatID, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChatParticipant(participant, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChatParticipant(participant, chatID, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::Callback_ChatClientCallbackI_removeChatParticipantPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChatParticipant(participant, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeChatParticipant(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::sdc::Callback_ChatClientCallbackI_removeChatParticipantPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeChatParticipant(participant, chatID, &__ctx, __del, __cookie);
    }

    void end_removeChatParticipant(const ::Ice::AsyncResultPtr&);
    
private:

    void removeChatParticipant(const ::sdc::User&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeChatParticipant(const ::sdc::User&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void appendMessageToChat(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant)
    {
        appendMessageToChat(message, chatID, participant, 0);
    }
    void appendMessageToChat(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context& __ctx)
    {
        appendMessageToChat(message, chatID, participant, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_appendMessageToChat(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant)
    {
        return begin_appendMessageToChat(message, chatID, participant, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_appendMessageToChat(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context& __ctx)
    {
        return begin_appendMessageToChat(message, chatID, participant, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_appendMessageToChat(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_appendMessageToChat(message, chatID, participant, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_appendMessageToChat(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_appendMessageToChat(message, chatID, participant, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_appendMessageToChat(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::sdc::Callback_ChatClientCallbackI_appendMessageToChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_appendMessageToChat(message, chatID, participant, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_appendMessageToChat(const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context& __ctx, const ::sdc::Callback_ChatClientCallbackI_appendMessageToChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_appendMessageToChat(message, chatID, participant, &__ctx, __del, __cookie);
    }

    void end_appendMessageToChat(const ::Ice::AsyncResultPtr&);
    
private:

    void appendMessageToChat(const ::sdc::ByteSeq&, const ::std::string&, const ::sdc::User&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_appendMessageToChat(const ::sdc::ByteSeq&, const ::std::string&, const ::sdc::User&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string echo(const ::std::string& message)
    {
        return echo(message, 0);
    }
    ::std::string echo(const ::std::string& message, const ::Ice::Context& __ctx)
    {
        return echo(message, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_echo(const ::std::string& message)
    {
        return begin_echo(message, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_echo(const ::std::string& message, const ::Ice::Context& __ctx)
    {
        return begin_echo(message, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_echo(const ::std::string& message, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_echo(message, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_echo(const ::std::string& message, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_echo(message, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_echo(const ::std::string& message, const ::sdc::Callback_ChatClientCallbackI_echoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_echo(message, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_echo(const ::std::string& message, const ::Ice::Context& __ctx, const ::sdc::Callback_ChatClientCallbackI_echoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_echo(message, &__ctx, __del, __cookie);
    }

    ::std::string end_echo(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string echo(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_echo(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ChatClientCallbackI> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ChatClientCallbackI*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ChatClientCallbackI*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class InterServerI : virtual public ::IceProxy::Ice::Object
{
public:

    ::sdc::User retrieveUser(const ::std::string& userID)
    {
        return retrieveUser(userID, 0);
    }
    ::sdc::User retrieveUser(const ::std::string& userID, const ::Ice::Context& __ctx)
    {
        return retrieveUser(userID, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string& userID)
    {
        return begin_retrieveUser(userID, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string& userID, const ::Ice::Context& __ctx)
    {
        return begin_retrieveUser(userID, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string& userID, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveUser(userID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string& userID, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveUser(userID, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string& userID, const ::sdc::Callback_InterServerI_retrieveUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveUser(userID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string& userID, const ::Ice::Context& __ctx, const ::sdc::Callback_InterServerI_retrieveUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_retrieveUser(userID, &__ctx, __del, __cookie);
    }

    ::sdc::User end_retrieveUser(const ::Ice::AsyncResultPtr&);
    
private:

    ::sdc::User retrieveUser(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_retrieveUser(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key)
    {
        invite(participant, chatID, key, 0);
    }
    void invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context& __ctx)
    {
        invite(participant, chatID, key, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key)
    {
        return begin_invite(participant, chatID, key, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context& __ctx)
    {
        return begin_invite(participant, chatID, key, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invite(participant, chatID, key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invite(participant, chatID, key, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::sdc::Callback_InterServerI_invitePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invite(participant, chatID, key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context& __ctx, const ::sdc::Callback_InterServerI_invitePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invite(participant, chatID, key, &__ctx, __del, __cookie);
    }

    void end_invite(const ::Ice::AsyncResultPtr&);
    
private:

    void invite(const ::sdc::User&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_invite(const ::sdc::User&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void sendMessage(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID)
    {
        sendMessage(sender, message, chatID, 0);
    }
    void sendMessage(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        sendMessage(sender, message, chatID, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID)
    {
        return begin_sendMessage(sender, message, chatID, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        return begin_sendMessage(sender, message, chatID, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(sender, message, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(sender, message, chatID, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::Callback_InterServerI_sendMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(sender, message, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::User& sender, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::sdc::Callback_InterServerI_sendMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(sender, message, chatID, &__ctx, __del, __cookie);
    }

    void end_sendMessage(const ::Ice::AsyncResultPtr&);
    
private:

    void sendMessage(const ::sdc::User&, const ::sdc::ByteSeq&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendMessage(const ::sdc::User&, const ::sdc::ByteSeq&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void leaveChat(const ::sdc::User& participant, const ::std::string& chatID)
    {
        leaveChat(participant, chatID, 0);
    }
    void leaveChat(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        leaveChat(participant, chatID, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_leaveChat(const ::sdc::User& participant, const ::std::string& chatID)
    {
        return begin_leaveChat(participant, chatID, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_leaveChat(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        return begin_leaveChat(participant, chatID, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_leaveChat(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_leaveChat(participant, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_leaveChat(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_leaveChat(participant, chatID, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_leaveChat(const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::Callback_InterServerI_leaveChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_leaveChat(participant, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_leaveChat(const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::sdc::Callback_InterServerI_leaveChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_leaveChat(participant, chatID, &__ctx, __del, __cookie);
    }

    void end_leaveChat(const ::Ice::AsyncResultPtr&);
    
private:

    void leaveChat(const ::sdc::User&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_leaveChat(const ::sdc::User&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void clientInitChat(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key)
    {
        clientInitChat(client, users, chatID, key, 0);
    }
    void clientInitChat(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context& __ctx)
    {
        clientInitChat(client, users, chatID, key, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_clientInitChat(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key)
    {
        return begin_clientInitChat(client, users, chatID, key, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clientInitChat(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context& __ctx)
    {
        return begin_clientInitChat(client, users, chatID, key, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clientInitChat(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientInitChat(client, users, chatID, key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clientInitChat(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientInitChat(client, users, chatID, key, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clientInitChat(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::sdc::Callback_InterServerI_clientInitChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientInitChat(client, users, chatID, key, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clientInitChat(const ::sdc::User& client, const ::sdc::StringSeq& users, const ::std::string& chatID, const ::sdc::ByteSeq& key, const ::Ice::Context& __ctx, const ::sdc::Callback_InterServerI_clientInitChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientInitChat(client, users, chatID, key, &__ctx, __del, __cookie);
    }

    void end_clientInitChat(const ::Ice::AsyncResultPtr&);
    
private:

    void clientInitChat(const ::sdc::User&, const ::sdc::StringSeq&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_clientInitChat(const ::sdc::User&, const ::sdc::StringSeq&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void clientAddChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID)
    {
        clientAddChatParticipant(client, participant, chatID, 0);
    }
    void clientAddChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        clientAddChatParticipant(client, participant, chatID, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_clientAddChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID)
    {
        return begin_clientAddChatParticipant(client, participant, chatID, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clientAddChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        return begin_clientAddChatParticipant(client, participant, chatID, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clientAddChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientAddChatParticipant(client, participant, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clientAddChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientAddChatParticipant(client, participant, chatID, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clientAddChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::Callback_InterServerI_clientAddChatParticipantPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientAddChatParticipant(client, participant, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clientAddChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::sdc::Callback_InterServerI_clientAddChatParticipantPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientAddChatParticipant(client, participant, chatID, &__ctx, __del, __cookie);
    }

    void end_clientAddChatParticipant(const ::Ice::AsyncResultPtr&);
    
private:

    void clientAddChatParticipant(const ::sdc::User&, const ::sdc::User&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_clientAddChatParticipant(const ::sdc::User&, const ::sdc::User&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void clientRemoveChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID)
    {
        clientRemoveChatParticipant(client, participant, chatID, 0);
    }
    void clientRemoveChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        clientRemoveChatParticipant(client, participant, chatID, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_clientRemoveChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID)
    {
        return begin_clientRemoveChatParticipant(client, participant, chatID, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clientRemoveChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx)
    {
        return begin_clientRemoveChatParticipant(client, participant, chatID, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clientRemoveChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientRemoveChatParticipant(client, participant, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clientRemoveChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientRemoveChatParticipant(client, participant, chatID, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clientRemoveChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::sdc::Callback_InterServerI_clientRemoveChatParticipantPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientRemoveChatParticipant(client, participant, chatID, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clientRemoveChatParticipant(const ::sdc::User& client, const ::sdc::User& participant, const ::std::string& chatID, const ::Ice::Context& __ctx, const ::sdc::Callback_InterServerI_clientRemoveChatParticipantPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientRemoveChatParticipant(client, participant, chatID, &__ctx, __del, __cookie);
    }

    void end_clientRemoveChatParticipant(const ::Ice::AsyncResultPtr&);
    
private:

    void clientRemoveChatParticipant(const ::sdc::User&, const ::sdc::User&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_clientRemoveChatParticipant(const ::sdc::User&, const ::sdc::User&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void clientAppendMessageToChat(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant)
    {
        clientAppendMessageToChat(client, message, chatID, participant, 0);
    }
    void clientAppendMessageToChat(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context& __ctx)
    {
        clientAppendMessageToChat(client, message, chatID, participant, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_clientAppendMessageToChat(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant)
    {
        return begin_clientAppendMessageToChat(client, message, chatID, participant, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clientAppendMessageToChat(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context& __ctx)
    {
        return begin_clientAppendMessageToChat(client, message, chatID, participant, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clientAppendMessageToChat(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientAppendMessageToChat(client, message, chatID, participant, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clientAppendMessageToChat(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientAppendMessageToChat(client, message, chatID, participant, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clientAppendMessageToChat(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::sdc::Callback_InterServerI_clientAppendMessageToChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientAppendMessageToChat(client, message, chatID, participant, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clientAppendMessageToChat(const ::sdc::User& client, const ::sdc::ByteSeq& message, const ::std::string& chatID, const ::sdc::User& participant, const ::Ice::Context& __ctx, const ::sdc::Callback_InterServerI_clientAppendMessageToChatPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clientAppendMessageToChat(client, message, chatID, participant, &__ctx, __del, __cookie);
    }

    void end_clientAppendMessageToChat(const ::Ice::AsyncResultPtr&);
    
private:

    void clientAppendMessageToChat(const ::sdc::User&, const ::sdc::ByteSeq&, const ::std::string&, const ::sdc::User&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_clientAppendMessageToChat(const ::sdc::User&, const ::sdc::ByteSeq&, const ::std::string&, const ::sdc::User&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<InterServerI> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<InterServerI> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<InterServerI*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<InterServerI*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace sdc
{

class SessionI : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void logout(const ::Ice::Context*) = 0;

    virtual ::sdc::User retrieveUser(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::std::string initChat(const ::Ice::Context*) = 0;

    virtual void leaveChat(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void invite(const ::sdc::User&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*) = 0;

    virtual void sendMessage(const ::sdc::ByteSeq&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void deleteUser(const ::sdc::User&, const ::Ice::Context*) = 0;

    virtual void saveLog(const ::std::string&, ::Ice::Long, const ::sdc::SecureContainer&, const ::Ice::Context*) = 0;

    virtual ::sdc::Loglist retrieveLoglist(const ::Ice::Context*) = 0;

    virtual ::sdc::SecureContainer retrieveLog(const ::std::string&, ::Ice::Long, const ::Ice::Context*) = 0;

    virtual void saveContactList(const ::sdc::SecureContainer&, const ::Ice::Context*) = 0;

    virtual ::sdc::SecureContainer retrieveContactList(const ::Ice::Context*) = 0;
};

class AuthenticationI : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void registerUser(const ::sdc::User&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::sdc::SessionIPrx login(const ::sdc::User&, const ::std::string&, const ::Ice::Identity&, const ::Ice::Context*) = 0;

    virtual ::std::string echo(const ::std::string&, const ::Ice::Context*) = 0;
};

class ChatClientCallbackI : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void initChat(const ::sdc::StringSeq&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*) = 0;

    virtual void addChatParticipant(const ::sdc::User&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void removeChatParticipant(const ::sdc::User&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void appendMessageToChat(const ::sdc::ByteSeq&, const ::std::string&, const ::sdc::User&, const ::Ice::Context*) = 0;

    virtual ::std::string echo(const ::std::string&, const ::Ice::Context*) = 0;
};

class InterServerI : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::sdc::User retrieveUser(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void invite(const ::sdc::User&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*) = 0;

    virtual void sendMessage(const ::sdc::User&, const ::sdc::ByteSeq&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void leaveChat(const ::sdc::User&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void clientInitChat(const ::sdc::User&, const ::sdc::StringSeq&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*) = 0;

    virtual void clientAddChatParticipant(const ::sdc::User&, const ::sdc::User&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void clientRemoveChatParticipant(const ::sdc::User&, const ::sdc::User&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void clientAppendMessageToChat(const ::sdc::User&, const ::sdc::ByteSeq&, const ::std::string&, const ::sdc::User&, const ::Ice::Context*) = 0;
};

}

}

namespace IceDelegateM
{

namespace sdc
{

class SessionI : virtual public ::IceDelegate::sdc::SessionI,
                 virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void logout(const ::Ice::Context*);

    virtual ::sdc::User retrieveUser(const ::std::string&, const ::Ice::Context*);

    virtual ::std::string initChat(const ::Ice::Context*);

    virtual void leaveChat(const ::std::string&, const ::Ice::Context*);

    virtual void invite(const ::sdc::User&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*);

    virtual void sendMessage(const ::sdc::ByteSeq&, const ::std::string&, const ::Ice::Context*);

    virtual void deleteUser(const ::sdc::User&, const ::Ice::Context*);

    virtual void saveLog(const ::std::string&, ::Ice::Long, const ::sdc::SecureContainer&, const ::Ice::Context*);

    virtual ::sdc::Loglist retrieveLoglist(const ::Ice::Context*);

    virtual ::sdc::SecureContainer retrieveLog(const ::std::string&, ::Ice::Long, const ::Ice::Context*);

    virtual void saveContactList(const ::sdc::SecureContainer&, const ::Ice::Context*);

    virtual ::sdc::SecureContainer retrieveContactList(const ::Ice::Context*);
};

class AuthenticationI : virtual public ::IceDelegate::sdc::AuthenticationI,
                        virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void registerUser(const ::sdc::User&, const ::std::string&, const ::Ice::Context*);

    virtual ::sdc::SessionIPrx login(const ::sdc::User&, const ::std::string&, const ::Ice::Identity&, const ::Ice::Context*);

    virtual ::std::string echo(const ::std::string&, const ::Ice::Context*);
};

class ChatClientCallbackI : virtual public ::IceDelegate::sdc::ChatClientCallbackI,
                            virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void initChat(const ::sdc::StringSeq&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*);

    virtual void addChatParticipant(const ::sdc::User&, const ::std::string&, const ::Ice::Context*);

    virtual void removeChatParticipant(const ::sdc::User&, const ::std::string&, const ::Ice::Context*);

    virtual void appendMessageToChat(const ::sdc::ByteSeq&, const ::std::string&, const ::sdc::User&, const ::Ice::Context*);

    virtual ::std::string echo(const ::std::string&, const ::Ice::Context*);
};

class InterServerI : virtual public ::IceDelegate::sdc::InterServerI,
                     virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::sdc::User retrieveUser(const ::std::string&, const ::Ice::Context*);

    virtual void invite(const ::sdc::User&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*);

    virtual void sendMessage(const ::sdc::User&, const ::sdc::ByteSeq&, const ::std::string&, const ::Ice::Context*);

    virtual void leaveChat(const ::sdc::User&, const ::std::string&, const ::Ice::Context*);

    virtual void clientInitChat(const ::sdc::User&, const ::sdc::StringSeq&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*);

    virtual void clientAddChatParticipant(const ::sdc::User&, const ::sdc::User&, const ::std::string&, const ::Ice::Context*);

    virtual void clientRemoveChatParticipant(const ::sdc::User&, const ::sdc::User&, const ::std::string&, const ::Ice::Context*);

    virtual void clientAppendMessageToChat(const ::sdc::User&, const ::sdc::ByteSeq&, const ::std::string&, const ::sdc::User&, const ::Ice::Context*);
};

}

}

namespace IceDelegateD
{

namespace sdc
{

class SessionI : virtual public ::IceDelegate::sdc::SessionI,
                 virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void logout(const ::Ice::Context*);

    virtual ::sdc::User retrieveUser(const ::std::string&, const ::Ice::Context*);

    virtual ::std::string initChat(const ::Ice::Context*);

    virtual void leaveChat(const ::std::string&, const ::Ice::Context*);

    virtual void invite(const ::sdc::User&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*);

    virtual void sendMessage(const ::sdc::ByteSeq&, const ::std::string&, const ::Ice::Context*);

    virtual void deleteUser(const ::sdc::User&, const ::Ice::Context*);

    virtual void saveLog(const ::std::string&, ::Ice::Long, const ::sdc::SecureContainer&, const ::Ice::Context*);

    virtual ::sdc::Loglist retrieveLoglist(const ::Ice::Context*);

    virtual ::sdc::SecureContainer retrieveLog(const ::std::string&, ::Ice::Long, const ::Ice::Context*);

    virtual void saveContactList(const ::sdc::SecureContainer&, const ::Ice::Context*);

    virtual ::sdc::SecureContainer retrieveContactList(const ::Ice::Context*);
};

class AuthenticationI : virtual public ::IceDelegate::sdc::AuthenticationI,
                        virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void registerUser(const ::sdc::User&, const ::std::string&, const ::Ice::Context*);

    virtual ::sdc::SessionIPrx login(const ::sdc::User&, const ::std::string&, const ::Ice::Identity&, const ::Ice::Context*);

    virtual ::std::string echo(const ::std::string&, const ::Ice::Context*);
};

class ChatClientCallbackI : virtual public ::IceDelegate::sdc::ChatClientCallbackI,
                            virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void initChat(const ::sdc::StringSeq&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*);

    virtual void addChatParticipant(const ::sdc::User&, const ::std::string&, const ::Ice::Context*);

    virtual void removeChatParticipant(const ::sdc::User&, const ::std::string&, const ::Ice::Context*);

    virtual void appendMessageToChat(const ::sdc::ByteSeq&, const ::std::string&, const ::sdc::User&, const ::Ice::Context*);

    virtual ::std::string echo(const ::std::string&, const ::Ice::Context*);
};

class InterServerI : virtual public ::IceDelegate::sdc::InterServerI,
                     virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::sdc::User retrieveUser(const ::std::string&, const ::Ice::Context*);

    virtual void invite(const ::sdc::User&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*);

    virtual void sendMessage(const ::sdc::User&, const ::sdc::ByteSeq&, const ::std::string&, const ::Ice::Context*);

    virtual void leaveChat(const ::sdc::User&, const ::std::string&, const ::Ice::Context*);

    virtual void clientInitChat(const ::sdc::User&, const ::sdc::StringSeq&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Context*);

    virtual void clientAddChatParticipant(const ::sdc::User&, const ::sdc::User&, const ::std::string&, const ::Ice::Context*);

    virtual void clientRemoveChatParticipant(const ::sdc::User&, const ::sdc::User&, const ::std::string&, const ::Ice::Context*);

    virtual void clientAppendMessageToChat(const ::sdc::User&, const ::sdc::ByteSeq&, const ::std::string&, const ::sdc::User&, const ::Ice::Context*);
};

}

}

namespace sdc
{

class SessionI : virtual public ::Ice::Object
{
public:

    typedef SessionIPrx ProxyType;
    typedef SessionIPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void logout(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___logout(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::sdc::User retrieveUser(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___retrieveUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string initChat(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___initChat(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void leaveChat(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___leaveChat(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void invite(const ::sdc::User&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___invite(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sendMessage(const ::sdc::ByteSeq&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendMessage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void deleteUser(const ::sdc::User&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___deleteUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void saveLog(const ::std::string&, ::Ice::Long, const ::sdc::SecureContainer&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___saveLog(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::sdc::Loglist retrieveLoglist(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___retrieveLoglist(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::sdc::SecureContainer retrieveLog(const ::std::string&, ::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___retrieveLog(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void saveContactList(const ::sdc::SecureContainer&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___saveContactList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::sdc::SecureContainer retrieveContactList(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___retrieveContactList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const SessionI& l, const SessionI& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const SessionI& l, const SessionI& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class AuthenticationI : virtual public ::Ice::Object
{
public:

    typedef AuthenticationIPrx ProxyType;
    typedef AuthenticationIPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void registerUser(const ::sdc::User&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___registerUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::sdc::SessionIPrx login(const ::sdc::User&, const ::std::string&, const ::Ice::Identity&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___login(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string echo(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___echo(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const AuthenticationI& l, const AuthenticationI& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const AuthenticationI& l, const AuthenticationI& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ChatClientCallbackI : virtual public ::Ice::Object
{
public:

    typedef ChatClientCallbackIPrx ProxyType;
    typedef ChatClientCallbackIPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void initChat(const ::sdc::StringSeq&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___initChat(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addChatParticipant(const ::sdc::User&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addChatParticipant(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeChatParticipant(const ::sdc::User&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeChatParticipant(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void appendMessageToChat(const ::sdc::ByteSeq&, const ::std::string&, const ::sdc::User&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___appendMessageToChat(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string echo(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___echo(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const ChatClientCallbackI& l, const ChatClientCallbackI& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ChatClientCallbackI& l, const ChatClientCallbackI& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class InterServerI : virtual public ::Ice::Object
{
public:

    typedef InterServerIPrx ProxyType;
    typedef InterServerIPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::sdc::User retrieveUser(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___retrieveUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void invite(const ::sdc::User&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___invite(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sendMessage(const ::sdc::User&, const ::sdc::ByteSeq&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendMessage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void leaveChat(const ::sdc::User&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___leaveChat(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void clientInitChat(const ::sdc::User&, const ::sdc::StringSeq&, const ::std::string&, const ::sdc::ByteSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___clientInitChat(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void clientAddChatParticipant(const ::sdc::User&, const ::sdc::User&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___clientAddChatParticipant(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void clientRemoveChatParticipant(const ::sdc::User&, const ::sdc::User&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___clientRemoveChatParticipant(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void clientAppendMessageToChat(const ::sdc::User&, const ::sdc::ByteSeq&, const ::std::string&, const ::sdc::User&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___clientAppendMessageToChat(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const InterServerI& l, const InterServerI& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const InterServerI& l, const InterServerI& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
#else
namespace Ice
{
template<>
struct StreamTrait< ::sdc::SDCException>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeUserException;
};

template<>
struct StreamTrait< ::sdc::AuthenticationException>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeUserException;
};

template<>
struct StreamTrait< ::sdc::SessionException>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeUserException;
};

template<>
struct StreamTrait< ::sdc::UserHandlingException>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeUserException;
};

template<>
struct StreamTrait< ::sdc::MessageException>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeUserException;
};

template<>
struct StreamTrait< ::sdc::LogException>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeUserException;
};

template<>
struct StreamTrait< ::sdc::ContactException>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeUserException;
};

template<>
struct StreamTrait< ::sdc::ChatClientCallbackException>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeUserException;
};

template<>
struct StreamTrait< ::sdc::ChatException>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeUserException;
};

template<>
struct StreamTrait< ::sdc::ParticipationException>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeUserException;
};

template<>
struct StreamTrait< ::sdc::MessageCallbackException>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeUserException;
};

template<>
struct StreamTrait< ::sdc::InterServerException>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeUserException;
};

template<>
struct StreamTrait< ::sdc::User>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeStruct;
    static const int minWireSize = 2;
};

template<>
struct StreamTrait< ::sdc::LogMessage>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeStruct;
    static const int minWireSize = 10;
};

template<>
struct StreamTrait< ::sdc::ChatlogEntry>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeStruct;
    static const int minWireSize = 9;
};

template<>
struct StreamTrait< ::sdc::SecureContainer>
{
    static const ::Ice::StreamTraitType type = ::Ice::StreamTraitTypeStruct;
    static const int minWireSize = 2;
};

}
#endif

namespace sdc
{

template<class T>
class CallbackNC_SessionI_logout : public Callback_SessionI_logout_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SessionI_logout(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_logout(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_SessionI_logoutPtr
newCallback_SessionI_logout(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_logout<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_logoutPtr
newCallback_SessionI_logout(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_logout<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_SessionI_logoutPtr
newCallback_SessionI_logout(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_logout<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_logoutPtr
newCallback_SessionI_logout(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_logout<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionI_logout : public Callback_SessionI_logout_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SessionI_logout(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_logout(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_SessionI_logoutPtr
newCallback_SessionI_logout(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_logout<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_logoutPtr
newCallback_SessionI_logout(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_logout<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_logoutPtr
newCallback_SessionI_logout(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_logout<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_logoutPtr
newCallback_SessionI_logout(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_logout<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_SessionI_retrieveUser : public Callback_SessionI_retrieveUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::sdc::User&);

    CallbackNC_SessionI_retrieveUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        ::sdc::User __ret;
        try
        {
            __ret = __proxy->end_retrieveUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_SessionI_retrieveUserPtr
newCallback_SessionI_retrieveUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::sdc::User&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_retrieveUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_retrieveUserPtr
newCallback_SessionI_retrieveUser(T* instance, void (T::*cb)(const ::sdc::User&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_retrieveUser<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionI_retrieveUser : public Callback_SessionI_retrieveUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::sdc::User&, const CT&);

    Callback_SessionI_retrieveUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        ::sdc::User __ret;
        try
        {
            __ret = __proxy->end_retrieveUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_SessionI_retrieveUserPtr
newCallback_SessionI_retrieveUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::sdc::User&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_retrieveUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_retrieveUserPtr
newCallback_SessionI_retrieveUser(T* instance, void (T::*cb)(const ::sdc::User&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_retrieveUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_SessionI_initChat : public Callback_SessionI_initChat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_SessionI_initChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_initChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_SessionI_initChatPtr
newCallback_SessionI_initChat(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_initChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_initChatPtr
newCallback_SessionI_initChat(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_initChat<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionI_initChat : public Callback_SessionI_initChat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_SessionI_initChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_initChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_SessionI_initChatPtr
newCallback_SessionI_initChat(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_initChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_initChatPtr
newCallback_SessionI_initChat(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_initChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_SessionI_leaveChat : public Callback_SessionI_leaveChat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SessionI_leaveChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_leaveChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_SessionI_leaveChatPtr
newCallback_SessionI_leaveChat(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_leaveChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_leaveChatPtr
newCallback_SessionI_leaveChat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_leaveChat<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_SessionI_leaveChatPtr
newCallback_SessionI_leaveChat(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_leaveChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_leaveChatPtr
newCallback_SessionI_leaveChat(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_leaveChat<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionI_leaveChat : public Callback_SessionI_leaveChat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SessionI_leaveChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_leaveChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_SessionI_leaveChatPtr
newCallback_SessionI_leaveChat(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_leaveChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_leaveChatPtr
newCallback_SessionI_leaveChat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_leaveChat<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_leaveChatPtr
newCallback_SessionI_leaveChat(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_leaveChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_leaveChatPtr
newCallback_SessionI_leaveChat(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_leaveChat<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_SessionI_invite : public Callback_SessionI_invite_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SessionI_invite(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_invite(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_SessionI_invitePtr
newCallback_SessionI_invite(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_invite<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_invitePtr
newCallback_SessionI_invite(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_invite<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_SessionI_invitePtr
newCallback_SessionI_invite(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_invite<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_invitePtr
newCallback_SessionI_invite(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_invite<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionI_invite : public Callback_SessionI_invite_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SessionI_invite(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_invite(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_SessionI_invitePtr
newCallback_SessionI_invite(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_invite<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_invitePtr
newCallback_SessionI_invite(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_invite<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_invitePtr
newCallback_SessionI_invite(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_invite<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_invitePtr
newCallback_SessionI_invite(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_invite<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_SessionI_sendMessage : public Callback_SessionI_sendMessage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SessionI_sendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_sendMessage(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_SessionI_sendMessagePtr
newCallback_SessionI_sendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_sendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_sendMessagePtr
newCallback_SessionI_sendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_sendMessage<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_SessionI_sendMessagePtr
newCallback_SessionI_sendMessage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_sendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_sendMessagePtr
newCallback_SessionI_sendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_sendMessage<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionI_sendMessage : public Callback_SessionI_sendMessage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SessionI_sendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_sendMessage(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_SessionI_sendMessagePtr
newCallback_SessionI_sendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_sendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_sendMessagePtr
newCallback_SessionI_sendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_sendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_sendMessagePtr
newCallback_SessionI_sendMessage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_sendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_sendMessagePtr
newCallback_SessionI_sendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_sendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_SessionI_deleteUser : public Callback_SessionI_deleteUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SessionI_deleteUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_deleteUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_SessionI_deleteUserPtr
newCallback_SessionI_deleteUser(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_deleteUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_deleteUserPtr
newCallback_SessionI_deleteUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_deleteUser<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_SessionI_deleteUserPtr
newCallback_SessionI_deleteUser(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_deleteUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_deleteUserPtr
newCallback_SessionI_deleteUser(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_deleteUser<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionI_deleteUser : public Callback_SessionI_deleteUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SessionI_deleteUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_deleteUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_SessionI_deleteUserPtr
newCallback_SessionI_deleteUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_deleteUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_deleteUserPtr
newCallback_SessionI_deleteUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_deleteUser<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_deleteUserPtr
newCallback_SessionI_deleteUser(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_deleteUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_deleteUserPtr
newCallback_SessionI_deleteUser(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_deleteUser<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_SessionI_saveLog : public Callback_SessionI_saveLog_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SessionI_saveLog(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_saveLog(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_SessionI_saveLogPtr
newCallback_SessionI_saveLog(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_saveLog<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_saveLogPtr
newCallback_SessionI_saveLog(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_saveLog<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_SessionI_saveLogPtr
newCallback_SessionI_saveLog(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_saveLog<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_saveLogPtr
newCallback_SessionI_saveLog(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_saveLog<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionI_saveLog : public Callback_SessionI_saveLog_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SessionI_saveLog(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_saveLog(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_SessionI_saveLogPtr
newCallback_SessionI_saveLog(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_saveLog<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_saveLogPtr
newCallback_SessionI_saveLog(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_saveLog<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_saveLogPtr
newCallback_SessionI_saveLog(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_saveLog<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_saveLogPtr
newCallback_SessionI_saveLog(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_saveLog<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_SessionI_retrieveLoglist : public Callback_SessionI_retrieveLoglist_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::sdc::Loglist&);

    CallbackNC_SessionI_retrieveLoglist(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        ::sdc::Loglist __ret;
        try
        {
            __ret = __proxy->end_retrieveLoglist(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_SessionI_retrieveLoglistPtr
newCallback_SessionI_retrieveLoglist(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::sdc::Loglist&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_retrieveLoglist<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_retrieveLoglistPtr
newCallback_SessionI_retrieveLoglist(T* instance, void (T::*cb)(const ::sdc::Loglist&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_retrieveLoglist<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionI_retrieveLoglist : public Callback_SessionI_retrieveLoglist_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::sdc::Loglist&, const CT&);

    Callback_SessionI_retrieveLoglist(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        ::sdc::Loglist __ret;
        try
        {
            __ret = __proxy->end_retrieveLoglist(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_SessionI_retrieveLoglistPtr
newCallback_SessionI_retrieveLoglist(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::sdc::Loglist&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_retrieveLoglist<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_retrieveLoglistPtr
newCallback_SessionI_retrieveLoglist(T* instance, void (T::*cb)(const ::sdc::Loglist&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_retrieveLoglist<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_SessionI_retrieveLog : public Callback_SessionI_retrieveLog_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::sdc::SecureContainer&);

    CallbackNC_SessionI_retrieveLog(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        ::sdc::SecureContainer __ret;
        try
        {
            __ret = __proxy->end_retrieveLog(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_SessionI_retrieveLogPtr
newCallback_SessionI_retrieveLog(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::sdc::SecureContainer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_retrieveLog<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_retrieveLogPtr
newCallback_SessionI_retrieveLog(T* instance, void (T::*cb)(const ::sdc::SecureContainer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_retrieveLog<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionI_retrieveLog : public Callback_SessionI_retrieveLog_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::sdc::SecureContainer&, const CT&);

    Callback_SessionI_retrieveLog(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        ::sdc::SecureContainer __ret;
        try
        {
            __ret = __proxy->end_retrieveLog(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_SessionI_retrieveLogPtr
newCallback_SessionI_retrieveLog(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::sdc::SecureContainer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_retrieveLog<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_retrieveLogPtr
newCallback_SessionI_retrieveLog(T* instance, void (T::*cb)(const ::sdc::SecureContainer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_retrieveLog<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_SessionI_saveContactList : public Callback_SessionI_saveContactList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SessionI_saveContactList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_saveContactList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_SessionI_saveContactListPtr
newCallback_SessionI_saveContactList(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_saveContactList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_saveContactListPtr
newCallback_SessionI_saveContactList(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_saveContactList<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_SessionI_saveContactListPtr
newCallback_SessionI_saveContactList(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_saveContactList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_saveContactListPtr
newCallback_SessionI_saveContactList(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_saveContactList<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionI_saveContactList : public Callback_SessionI_saveContactList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SessionI_saveContactList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_saveContactList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_SessionI_saveContactListPtr
newCallback_SessionI_saveContactList(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_saveContactList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_saveContactListPtr
newCallback_SessionI_saveContactList(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_saveContactList<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_saveContactListPtr
newCallback_SessionI_saveContactList(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_saveContactList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_saveContactListPtr
newCallback_SessionI_saveContactList(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_saveContactList<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_SessionI_retrieveContactList : public Callback_SessionI_retrieveContactList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::sdc::SecureContainer&);

    CallbackNC_SessionI_retrieveContactList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        ::sdc::SecureContainer __ret;
        try
        {
            __ret = __proxy->end_retrieveContactList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_SessionI_retrieveContactListPtr
newCallback_SessionI_retrieveContactList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::sdc::SecureContainer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_retrieveContactList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_SessionI_retrieveContactListPtr
newCallback_SessionI_retrieveContactList(T* instance, void (T::*cb)(const ::sdc::SecureContainer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SessionI_retrieveContactList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_SessionI_retrieveContactList : public Callback_SessionI_retrieveContactList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::sdc::SecureContainer&, const CT&);

    Callback_SessionI_retrieveContactList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::SessionIPrx __proxy = ::sdc::SessionIPrx::uncheckedCast(__result->getProxy());
        ::sdc::SecureContainer __ret;
        try
        {
            __ret = __proxy->end_retrieveContactList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_SessionI_retrieveContactListPtr
newCallback_SessionI_retrieveContactList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::sdc::SecureContainer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_retrieveContactList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_SessionI_retrieveContactListPtr
newCallback_SessionI_retrieveContactList(T* instance, void (T::*cb)(const ::sdc::SecureContainer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SessionI_retrieveContactList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_AuthenticationI_registerUser : public Callback_AuthenticationI_registerUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_AuthenticationI_registerUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::AuthenticationIPrx __proxy = ::sdc::AuthenticationIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_registerUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_AuthenticationI_registerUserPtr
newCallback_AuthenticationI_registerUser(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AuthenticationI_registerUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_AuthenticationI_registerUserPtr
newCallback_AuthenticationI_registerUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AuthenticationI_registerUser<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_AuthenticationI_registerUserPtr
newCallback_AuthenticationI_registerUser(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AuthenticationI_registerUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_AuthenticationI_registerUserPtr
newCallback_AuthenticationI_registerUser(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AuthenticationI_registerUser<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_AuthenticationI_registerUser : public Callback_AuthenticationI_registerUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_AuthenticationI_registerUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::AuthenticationIPrx __proxy = ::sdc::AuthenticationIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_registerUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_AuthenticationI_registerUserPtr
newCallback_AuthenticationI_registerUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AuthenticationI_registerUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_AuthenticationI_registerUserPtr
newCallback_AuthenticationI_registerUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AuthenticationI_registerUser<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_AuthenticationI_registerUserPtr
newCallback_AuthenticationI_registerUser(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AuthenticationI_registerUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_AuthenticationI_registerUserPtr
newCallback_AuthenticationI_registerUser(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AuthenticationI_registerUser<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_AuthenticationI_login : public Callback_AuthenticationI_login_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::sdc::SessionIPrx&);

    CallbackNC_AuthenticationI_login(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::AuthenticationIPrx __proxy = ::sdc::AuthenticationIPrx::uncheckedCast(__result->getProxy());
        ::sdc::SessionIPrx __ret;
        try
        {
            __ret = __proxy->end_login(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_AuthenticationI_loginPtr
newCallback_AuthenticationI_login(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::sdc::SessionIPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AuthenticationI_login<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_AuthenticationI_loginPtr
newCallback_AuthenticationI_login(T* instance, void (T::*cb)(const ::sdc::SessionIPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AuthenticationI_login<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_AuthenticationI_login : public Callback_AuthenticationI_login_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::sdc::SessionIPrx&, const CT&);

    Callback_AuthenticationI_login(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::AuthenticationIPrx __proxy = ::sdc::AuthenticationIPrx::uncheckedCast(__result->getProxy());
        ::sdc::SessionIPrx __ret;
        try
        {
            __ret = __proxy->end_login(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_AuthenticationI_loginPtr
newCallback_AuthenticationI_login(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::sdc::SessionIPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AuthenticationI_login<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_AuthenticationI_loginPtr
newCallback_AuthenticationI_login(T* instance, void (T::*cb)(const ::sdc::SessionIPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AuthenticationI_login<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_AuthenticationI_echo : public Callback_AuthenticationI_echo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_AuthenticationI_echo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::AuthenticationIPrx __proxy = ::sdc::AuthenticationIPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_echo(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_AuthenticationI_echoPtr
newCallback_AuthenticationI_echo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AuthenticationI_echo<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_AuthenticationI_echoPtr
newCallback_AuthenticationI_echo(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AuthenticationI_echo<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_AuthenticationI_echo : public Callback_AuthenticationI_echo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_AuthenticationI_echo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::AuthenticationIPrx __proxy = ::sdc::AuthenticationIPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_echo(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_AuthenticationI_echoPtr
newCallback_AuthenticationI_echo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AuthenticationI_echo<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_AuthenticationI_echoPtr
newCallback_AuthenticationI_echo(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AuthenticationI_echo<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatClientCallbackI_initChat : public Callback_ChatClientCallbackI_initChat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatClientCallbackI_initChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::ChatClientCallbackIPrx __proxy = ::sdc::ChatClientCallbackIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_initChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_ChatClientCallbackI_initChatPtr
newCallback_ChatClientCallbackI_initChat(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_initChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_initChatPtr
newCallback_ChatClientCallbackI_initChat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_initChat<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_initChatPtr
newCallback_ChatClientCallbackI_initChat(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_initChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_initChatPtr
newCallback_ChatClientCallbackI_initChat(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_initChat<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatClientCallbackI_initChat : public Callback_ChatClientCallbackI_initChat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatClientCallbackI_initChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::ChatClientCallbackIPrx __proxy = ::sdc::ChatClientCallbackIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_initChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatClientCallbackI_initChatPtr
newCallback_ChatClientCallbackI_initChat(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_initChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_initChatPtr
newCallback_ChatClientCallbackI_initChat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_initChat<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_initChatPtr
newCallback_ChatClientCallbackI_initChat(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_initChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_initChatPtr
newCallback_ChatClientCallbackI_initChat(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_initChat<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatClientCallbackI_addChatParticipant : public Callback_ChatClientCallbackI_addChatParticipant_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatClientCallbackI_addChatParticipant(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::ChatClientCallbackIPrx __proxy = ::sdc::ChatClientCallbackIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addChatParticipant(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_ChatClientCallbackI_addChatParticipantPtr
newCallback_ChatClientCallbackI_addChatParticipant(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_addChatParticipant<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_addChatParticipantPtr
newCallback_ChatClientCallbackI_addChatParticipant(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_addChatParticipant<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_addChatParticipantPtr
newCallback_ChatClientCallbackI_addChatParticipant(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_addChatParticipant<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_addChatParticipantPtr
newCallback_ChatClientCallbackI_addChatParticipant(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_addChatParticipant<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatClientCallbackI_addChatParticipant : public Callback_ChatClientCallbackI_addChatParticipant_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatClientCallbackI_addChatParticipant(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::ChatClientCallbackIPrx __proxy = ::sdc::ChatClientCallbackIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addChatParticipant(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatClientCallbackI_addChatParticipantPtr
newCallback_ChatClientCallbackI_addChatParticipant(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_addChatParticipant<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_addChatParticipantPtr
newCallback_ChatClientCallbackI_addChatParticipant(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_addChatParticipant<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_addChatParticipantPtr
newCallback_ChatClientCallbackI_addChatParticipant(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_addChatParticipant<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_addChatParticipantPtr
newCallback_ChatClientCallbackI_addChatParticipant(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_addChatParticipant<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatClientCallbackI_removeChatParticipant : public Callback_ChatClientCallbackI_removeChatParticipant_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatClientCallbackI_removeChatParticipant(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::ChatClientCallbackIPrx __proxy = ::sdc::ChatClientCallbackIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeChatParticipant(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_ChatClientCallbackI_removeChatParticipantPtr
newCallback_ChatClientCallbackI_removeChatParticipant(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_removeChatParticipant<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_removeChatParticipantPtr
newCallback_ChatClientCallbackI_removeChatParticipant(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_removeChatParticipant<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_removeChatParticipantPtr
newCallback_ChatClientCallbackI_removeChatParticipant(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_removeChatParticipant<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_removeChatParticipantPtr
newCallback_ChatClientCallbackI_removeChatParticipant(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_removeChatParticipant<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatClientCallbackI_removeChatParticipant : public Callback_ChatClientCallbackI_removeChatParticipant_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatClientCallbackI_removeChatParticipant(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::ChatClientCallbackIPrx __proxy = ::sdc::ChatClientCallbackIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_removeChatParticipant(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatClientCallbackI_removeChatParticipantPtr
newCallback_ChatClientCallbackI_removeChatParticipant(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_removeChatParticipant<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_removeChatParticipantPtr
newCallback_ChatClientCallbackI_removeChatParticipant(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_removeChatParticipant<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_removeChatParticipantPtr
newCallback_ChatClientCallbackI_removeChatParticipant(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_removeChatParticipant<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_removeChatParticipantPtr
newCallback_ChatClientCallbackI_removeChatParticipant(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_removeChatParticipant<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatClientCallbackI_appendMessageToChat : public Callback_ChatClientCallbackI_appendMessageToChat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatClientCallbackI_appendMessageToChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::ChatClientCallbackIPrx __proxy = ::sdc::ChatClientCallbackIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_appendMessageToChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_ChatClientCallbackI_appendMessageToChatPtr
newCallback_ChatClientCallbackI_appendMessageToChat(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_appendMessageToChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_appendMessageToChatPtr
newCallback_ChatClientCallbackI_appendMessageToChat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_appendMessageToChat<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_appendMessageToChatPtr
newCallback_ChatClientCallbackI_appendMessageToChat(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_appendMessageToChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_appendMessageToChatPtr
newCallback_ChatClientCallbackI_appendMessageToChat(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_appendMessageToChat<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatClientCallbackI_appendMessageToChat : public Callback_ChatClientCallbackI_appendMessageToChat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatClientCallbackI_appendMessageToChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::ChatClientCallbackIPrx __proxy = ::sdc::ChatClientCallbackIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_appendMessageToChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatClientCallbackI_appendMessageToChatPtr
newCallback_ChatClientCallbackI_appendMessageToChat(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_appendMessageToChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_appendMessageToChatPtr
newCallback_ChatClientCallbackI_appendMessageToChat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_appendMessageToChat<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_appendMessageToChatPtr
newCallback_ChatClientCallbackI_appendMessageToChat(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_appendMessageToChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_appendMessageToChatPtr
newCallback_ChatClientCallbackI_appendMessageToChat(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_appendMessageToChat<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatClientCallbackI_echo : public Callback_ChatClientCallbackI_echo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_ChatClientCallbackI_echo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::ChatClientCallbackIPrx __proxy = ::sdc::ChatClientCallbackIPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_echo(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ChatClientCallbackI_echoPtr
newCallback_ChatClientCallbackI_echo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_echo<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatClientCallbackI_echoPtr
newCallback_ChatClientCallbackI_echo(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatClientCallbackI_echo<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatClientCallbackI_echo : public Callback_ChatClientCallbackI_echo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_ChatClientCallbackI_echo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::ChatClientCallbackIPrx __proxy = ::sdc::ChatClientCallbackIPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_echo(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatClientCallbackI_echoPtr
newCallback_ChatClientCallbackI_echo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_echo<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatClientCallbackI_echoPtr
newCallback_ChatClientCallbackI_echo(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatClientCallbackI_echo<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InterServerI_retrieveUser : public Callback_InterServerI_retrieveUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::sdc::User&);

    CallbackNC_InterServerI_retrieveUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        ::sdc::User __ret;
        try
        {
            __ret = __proxy->end_retrieveUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_InterServerI_retrieveUserPtr
newCallback_InterServerI_retrieveUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::sdc::User&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_retrieveUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_retrieveUserPtr
newCallback_InterServerI_retrieveUser(T* instance, void (T::*cb)(const ::sdc::User&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_retrieveUser<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_InterServerI_retrieveUser : public Callback_InterServerI_retrieveUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::sdc::User&, const CT&);

    Callback_InterServerI_retrieveUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        ::sdc::User __ret;
        try
        {
            __ret = __proxy->end_retrieveUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InterServerI_retrieveUserPtr
newCallback_InterServerI_retrieveUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::sdc::User&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_retrieveUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_retrieveUserPtr
newCallback_InterServerI_retrieveUser(T* instance, void (T::*cb)(const ::sdc::User&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_retrieveUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_InterServerI_invite : public Callback_InterServerI_invite_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_InterServerI_invite(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_invite(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_InterServerI_invitePtr
newCallback_InterServerI_invite(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_invite<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_invitePtr
newCallback_InterServerI_invite(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_invite<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_InterServerI_invitePtr
newCallback_InterServerI_invite(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_invite<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_invitePtr
newCallback_InterServerI_invite(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_invite<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_InterServerI_invite : public Callback_InterServerI_invite_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_InterServerI_invite(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_invite(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InterServerI_invitePtr
newCallback_InterServerI_invite(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_invite<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_invitePtr
newCallback_InterServerI_invite(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_invite<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_invitePtr
newCallback_InterServerI_invite(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_invite<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_invitePtr
newCallback_InterServerI_invite(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_invite<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_InterServerI_sendMessage : public Callback_InterServerI_sendMessage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_InterServerI_sendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_sendMessage(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_InterServerI_sendMessagePtr
newCallback_InterServerI_sendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_sendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_sendMessagePtr
newCallback_InterServerI_sendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_sendMessage<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_InterServerI_sendMessagePtr
newCallback_InterServerI_sendMessage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_sendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_sendMessagePtr
newCallback_InterServerI_sendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_sendMessage<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_InterServerI_sendMessage : public Callback_InterServerI_sendMessage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_InterServerI_sendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_sendMessage(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InterServerI_sendMessagePtr
newCallback_InterServerI_sendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_sendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_sendMessagePtr
newCallback_InterServerI_sendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_sendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_sendMessagePtr
newCallback_InterServerI_sendMessage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_sendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_sendMessagePtr
newCallback_InterServerI_sendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_sendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_InterServerI_leaveChat : public Callback_InterServerI_leaveChat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_InterServerI_leaveChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_leaveChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_InterServerI_leaveChatPtr
newCallback_InterServerI_leaveChat(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_leaveChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_leaveChatPtr
newCallback_InterServerI_leaveChat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_leaveChat<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_InterServerI_leaveChatPtr
newCallback_InterServerI_leaveChat(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_leaveChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_leaveChatPtr
newCallback_InterServerI_leaveChat(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_leaveChat<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_InterServerI_leaveChat : public Callback_InterServerI_leaveChat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_InterServerI_leaveChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_leaveChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InterServerI_leaveChatPtr
newCallback_InterServerI_leaveChat(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_leaveChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_leaveChatPtr
newCallback_InterServerI_leaveChat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_leaveChat<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_leaveChatPtr
newCallback_InterServerI_leaveChat(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_leaveChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_leaveChatPtr
newCallback_InterServerI_leaveChat(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_leaveChat<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_InterServerI_clientInitChat : public Callback_InterServerI_clientInitChat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_InterServerI_clientInitChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_clientInitChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_InterServerI_clientInitChatPtr
newCallback_InterServerI_clientInitChat(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientInitChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_clientInitChatPtr
newCallback_InterServerI_clientInitChat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientInitChat<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_InterServerI_clientInitChatPtr
newCallback_InterServerI_clientInitChat(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientInitChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_clientInitChatPtr
newCallback_InterServerI_clientInitChat(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientInitChat<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_InterServerI_clientInitChat : public Callback_InterServerI_clientInitChat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_InterServerI_clientInitChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_clientInitChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InterServerI_clientInitChatPtr
newCallback_InterServerI_clientInitChat(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientInitChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_clientInitChatPtr
newCallback_InterServerI_clientInitChat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientInitChat<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_clientInitChatPtr
newCallback_InterServerI_clientInitChat(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientInitChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_clientInitChatPtr
newCallback_InterServerI_clientInitChat(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientInitChat<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_InterServerI_clientAddChatParticipant : public Callback_InterServerI_clientAddChatParticipant_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_InterServerI_clientAddChatParticipant(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_clientAddChatParticipant(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_InterServerI_clientAddChatParticipantPtr
newCallback_InterServerI_clientAddChatParticipant(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientAddChatParticipant<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_clientAddChatParticipantPtr
newCallback_InterServerI_clientAddChatParticipant(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientAddChatParticipant<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_InterServerI_clientAddChatParticipantPtr
newCallback_InterServerI_clientAddChatParticipant(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientAddChatParticipant<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_clientAddChatParticipantPtr
newCallback_InterServerI_clientAddChatParticipant(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientAddChatParticipant<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_InterServerI_clientAddChatParticipant : public Callback_InterServerI_clientAddChatParticipant_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_InterServerI_clientAddChatParticipant(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_clientAddChatParticipant(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InterServerI_clientAddChatParticipantPtr
newCallback_InterServerI_clientAddChatParticipant(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientAddChatParticipant<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_clientAddChatParticipantPtr
newCallback_InterServerI_clientAddChatParticipant(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientAddChatParticipant<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_clientAddChatParticipantPtr
newCallback_InterServerI_clientAddChatParticipant(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientAddChatParticipant<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_clientAddChatParticipantPtr
newCallback_InterServerI_clientAddChatParticipant(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientAddChatParticipant<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_InterServerI_clientRemoveChatParticipant : public Callback_InterServerI_clientRemoveChatParticipant_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_InterServerI_clientRemoveChatParticipant(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_clientRemoveChatParticipant(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_InterServerI_clientRemoveChatParticipantPtr
newCallback_InterServerI_clientRemoveChatParticipant(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientRemoveChatParticipant<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_clientRemoveChatParticipantPtr
newCallback_InterServerI_clientRemoveChatParticipant(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientRemoveChatParticipant<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_InterServerI_clientRemoveChatParticipantPtr
newCallback_InterServerI_clientRemoveChatParticipant(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientRemoveChatParticipant<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_clientRemoveChatParticipantPtr
newCallback_InterServerI_clientRemoveChatParticipant(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientRemoveChatParticipant<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_InterServerI_clientRemoveChatParticipant : public Callback_InterServerI_clientRemoveChatParticipant_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_InterServerI_clientRemoveChatParticipant(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_clientRemoveChatParticipant(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InterServerI_clientRemoveChatParticipantPtr
newCallback_InterServerI_clientRemoveChatParticipant(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientRemoveChatParticipant<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_clientRemoveChatParticipantPtr
newCallback_InterServerI_clientRemoveChatParticipant(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientRemoveChatParticipant<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_clientRemoveChatParticipantPtr
newCallback_InterServerI_clientRemoveChatParticipant(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientRemoveChatParticipant<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_clientRemoveChatParticipantPtr
newCallback_InterServerI_clientRemoveChatParticipant(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientRemoveChatParticipant<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_InterServerI_clientAppendMessageToChat : public Callback_InterServerI_clientAppendMessageToChat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_InterServerI_clientAppendMessageToChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_clientAppendMessageToChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_InterServerI_clientAppendMessageToChatPtr
newCallback_InterServerI_clientAppendMessageToChat(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientAppendMessageToChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_clientAppendMessageToChatPtr
newCallback_InterServerI_clientAppendMessageToChat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientAppendMessageToChat<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_InterServerI_clientAppendMessageToChatPtr
newCallback_InterServerI_clientAppendMessageToChat(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientAppendMessageToChat<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_InterServerI_clientAppendMessageToChatPtr
newCallback_InterServerI_clientAppendMessageToChat(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InterServerI_clientAppendMessageToChat<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_InterServerI_clientAppendMessageToChat : public Callback_InterServerI_clientAppendMessageToChat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_InterServerI_clientAppendMessageToChat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::sdc::InterServerIPrx __proxy = ::sdc::InterServerIPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_clientAppendMessageToChat(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_InterServerI_clientAppendMessageToChatPtr
newCallback_InterServerI_clientAppendMessageToChat(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientAppendMessageToChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_clientAppendMessageToChatPtr
newCallback_InterServerI_clientAppendMessageToChat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientAppendMessageToChat<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_clientAppendMessageToChatPtr
newCallback_InterServerI_clientAppendMessageToChat(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientAppendMessageToChat<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_InterServerI_clientAppendMessageToChatPtr
newCallback_InterServerI_clientAppendMessageToChat(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InterServerI_clientAppendMessageToChat<T, CT>(instance, 0, excb, sentcb);
}

}

#endif
